<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PVM & Gross Margin Bridge Tool - Standalone</title>
    <style>
/* ============================================
   PVM Bridge Tool - Professional Services Stylesheet
   ============================================
   Modern, clean design inspired by leading
   professional services firms.
   ============================================ */

/* --------------------------------------------
   CSS Variables / Design Tokens
   -------------------------------------------- */
:root {
    /* Professional Services Color Palette */
    --color-primary: #003B5C;          /* Deep Navy Blue */
    --color-primary-dark: #002741;     /* Darker Navy */
    --color-primary-light: #E6F0F5;    /* Light Blue Tint */

    --color-secondary: #0066CC;        /* Professional Blue */
    --color-accent: #00A9CE;           /* Teal Accent */

    --color-success: #10B981;          /* Modern Green */
    --color-success-light: #D1FAE5;

    --color-warning: #F59E0B;          /* Amber */
    --color-warning-light: #FEF3C7;

    --color-error: #EF4444;            /* Red */
    --color-error-light: #FEE2E2;

    --color-text: #1F2937;             /* Dark Gray */
    --color-text-muted: #6B7280;       /* Medium Gray */
    --color-text-light: #9CA3AF;       /* Light Gray */

    --color-bg: #F8FAFC;               /* Off-white Background */
    --color-bg-white: #FFFFFF;
    --color-bg-card: #FFFFFF;
    --color-border: #E2E8F0;           /* Light Border */
    --color-border-dark: #CBD5E1;      /* Medium Border */

    /* Positive/Negative for financial data */
    --color-positive: #10B981;
    --color-negative: #EF4444;

    /* Typography */
    --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    --font-mono: 'SF Mono', SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;

    /* Spacing */
    --space-xs: 0.25rem;
    --space-sm: 0.5rem;
    --space-md: 1rem;
    --space-lg: 1.5rem;
    --space-xl: 2rem;
    --space-2xl: 3rem;
    --space-3xl: 4rem;

    /* Border Radius */
    --radius-sm: 6px;
    --radius-md: 10px;
    --radius-lg: 14px;

    /* Shadows - Enhanced for depth */
    --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08);
    --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
    --shadow-lg: 0 10px 24px rgba(0, 0, 0, 0.10);
    --shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.12);
}

/* --------------------------------------------
   Reset & Base Styles
   -------------------------------------------- */
*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html {
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

body {
    font-family: var(--font-sans);
    font-size: 1rem;
    line-height: 1.5;
    color: var(--color-text);
    background-color: var(--color-bg);
    min-height: 100vh;
}

/* --------------------------------------------
   Layout
   -------------------------------------------- */
#app {
    min-height: 100vh;
}

.screen {
    display: none;
    min-height: 100vh;
    padding: var(--space-xl) var(--space-md);
}

.screen.active {
    display: block;
}

.container {
    max-width: 800px;
    margin: 0 auto;
}

.container.wide {
    max-width: 1200px;
}

/* --------------------------------------------
   Typography
   -------------------------------------------- */
h1 {
    font-size: 2rem;
    font-weight: 700;
    color: var(--color-text);
    margin-bottom: var(--space-sm);
}

h2 {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--color-text);
    margin-bottom: var(--space-md);
}

h3 {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--color-text);
    margin-bottom: var(--space-sm);
}

h4 {
    font-size: 1rem;
    font-weight: 600;
    color: var(--color-text);
    margin-bottom: var(--space-sm);
}

p {
    margin-bottom: var(--space-md);
}

.subtitle {
    font-size: 1.125rem;
    color: var(--color-text-muted);
}

/* --------------------------------------------
   Buttons
   -------------------------------------------- */
button {
    font-family: inherit;
    font-size: 1rem;
    cursor: pointer;
    border: none;
    border-radius: var(--radius-md);
    padding: var(--space-sm) var(--space-md);
    transition: all 0.15s ease;
}

button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.btn-primary {
    background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
    color: white;
    font-weight: 600;
    box-shadow: var(--shadow-sm);
}

.btn-primary:hover:not(:disabled) {
    background: linear-gradient(135deg, var(--color-primary-dark) 0%, var(--color-primary) 100%);
    box-shadow: var(--shadow-md);
    transform: translateY(-1px);
}

.btn-secondary {
    background-color: var(--color-bg-white);
    color: var(--color-text);
    border: 2px solid var(--color-border-dark);
    font-weight: 500;
}

.btn-secondary:hover:not(:disabled) {
    background-color: var(--color-bg);
    border-color: var(--color-primary);
}

.btn-large {
    padding: var(--space-lg) var(--space-2xl);
    font-size: 1.125rem;
    font-weight: 600;
    box-shadow: var(--shadow-md);
}

.btn-back {
    background: none;
    color: var(--color-primary);
    padding: var(--space-xs) 0;
    font-weight: 500;
}

.btn-back:hover {
    color: var(--color-primary-dark);
}

.btn-remove {
    background: none;
    color: var(--color-text-muted);
    padding: var(--space-xs);
    font-size: 1.25rem;
    line-height: 1;
}

.btn-remove:hover {
    color: var(--color-error);
}

/* --------------------------------------------
   Form Elements
   -------------------------------------------- */
select, input[type="text"], input[type="date"] {
    font-family: inherit;
    font-size: 1rem;
    padding: var(--space-sm) var(--space-md);
    border: 1px solid var(--color-border-dark);
    border-radius: var(--radius-md);
    background-color: var(--color-bg-white);
    color: var(--color-text);
    width: 100%;
    max-width: 300px;
}

select:focus, input:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px var(--color-primary-light);
}

label {
    display: block;
    font-weight: 500;
    margin-bottom: var(--space-xs);
    color: var(--color-text);
}

/* Checkboxes */
.checkbox-label {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-sm);
    cursor: pointer;
    border-radius: var(--radius-sm);
}

.checkbox-label:hover {
    background-color: var(--color-bg);
}

.checkbox-label input[type="checkbox"] {
    width: 18px;
    height: 18px;
    accent-color: var(--color-primary);
}

/* Fiscal Year Selection */
.fiscal-year-selection {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: var(--space-md);
    margin-top: var(--space-md);
    padding: var(--space-md);
    background: var(--color-bg);
    border-radius: var(--radius-md);
}

.fiscal-year-option {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-md);
    background: white;
    border: 2px solid var(--color-border);
    border-radius: var(--radius-md);
    cursor: pointer;
    transition: all 0.2s ease;
}

.fiscal-year-option:hover {
    border-color: var(--color-secondary);
    background: var(--color-bg);
}

.fiscal-year-option input[type="checkbox"] {
    width: 20px;
    height: 20px;
    accent-color: var(--color-primary);
}

.fiscal-year-option input[type="checkbox"]:checked + .fy-label {
    font-weight: 600;
    color: var(--color-primary);
}

.fy-label {
    font-size: 0.95rem;
    color: var(--color-text);
}

.fy-date-range {
    font-size: 0.8rem;
    color: var(--color-text-muted);
    margin-top: 2px;
}

/* Radio buttons */
.radio-group {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
}

.radio-option {
    display: flex;
    align-items: flex-start;
    gap: var(--space-sm);
    padding: var(--space-md);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    cursor: pointer;
}

.radio-option:hover {
    border-color: var(--color-primary);
}

.radio-option input[type="radio"] {
    margin-top: 4px;
    accent-color: var(--color-primary);
}

.radio-label {
    display: flex;
    flex-direction: column;
}

.radio-desc {
    font-size: 0.875rem;
    color: var(--color-text-muted);
}

/* --------------------------------------------
   Screen 1: Landing
   -------------------------------------------- */
.landing-header {
    text-align: center;
    margin-bottom: var(--space-2xl);
}

.disclaimer-box {
    background-color: var(--color-bg-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-xl);
    margin-bottom: var(--space-xl);
}

.disclaimer-box h2 {
    margin-bottom: var(--space-md);
}

.disclaimer-box ul {
    list-style: none;
    margin-bottom: var(--space-md);
}

.disclaimer-box li {
    padding: var(--space-sm) 0;
    padding-left: var(--space-lg);
    position: relative;
}

.disclaimer-box li::before {
    content: '‚úì';
    position: absolute;
    left: 0;
    color: var(--color-success);
    font-weight: bold;
}

.disclaimer-note {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    margin-bottom: 0;
}

/* Mode Selection */
.mode-selection {
    margin-bottom: var(--space-xl);
}

.mode-selection h3 {
    text-align: center;
    margin-bottom: var(--space-md);
}

.mode-buttons {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-md);
}

.mode-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: var(--space-xl);
    background-color: var(--color-bg-white);
    border: 2px solid var(--color-border);
    border-radius: var(--radius-lg);
    text-align: center;
    box-shadow: var(--shadow-sm);
    transition: all 0.2s ease;
}

.mode-btn:hover {
    border-color: var(--color-primary);
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
}

.mode-btn.selected {
    border-color: var(--color-primary);
    background: linear-gradient(135deg, var(--color-primary-light) 0%, #FFFFFF 100%);
    box-shadow: var(--shadow-md);
}

.mode-icon {
    font-size: 2rem;
    margin-bottom: var(--space-sm);
}

.mode-title {
    font-weight: 600;
    margin-bottom: var(--space-xs);
}

.mode-desc {
    font-size: 0.875rem;
    color: var(--color-text-muted);
}

#btn-start {
    display: block;
    width: 100%;
    max-width: 300px;
    margin: 0 auto;
}

/* --------------------------------------------
   Screen Header (common)
   -------------------------------------------- */
.screen-header {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    margin-bottom: var(--space-2xl);
    flex-wrap: wrap;
    padding-bottom: var(--space-lg);
    border-bottom: 2px solid var(--color-border);
}

.screen-header h2 {
    flex: 1;
    margin-bottom: 0;
    color: var(--color-primary);
    font-weight: 700;
}

.mode-indicator {
    background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-secondary) 100%);
    color: white;
    padding: var(--space-sm) var(--space-lg);
    border-radius: var(--radius-lg);
    font-size: 0.875rem;
    font-weight: 600;
    letter-spacing: 0.5px;
    box-shadow: var(--shadow-sm);
}

.header-actions {
    display: flex;
    gap: var(--space-sm);
}

/* --------------------------------------------
   Screen 2: Upload
   -------------------------------------------- */
.upload-area {
    border: 2px dashed var(--color-border-dark);
    border-radius: var(--radius-lg);
    padding: var(--space-2xl);
    text-align: center;
    cursor: pointer;
    transition: all 0.15s ease;
    margin-bottom: var(--space-lg);
}

.upload-area:hover, .upload-area.drag-over {
    border-color: var(--color-primary);
    background-color: var(--color-primary-light);
}

.upload-icon {
    font-size: 3rem;
    display: block;
    margin-bottom: var(--space-md);
}

.upload-text {
    font-weight: 500;
    margin-bottom: var(--space-xs);
}

.upload-subtext {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    margin-bottom: 0;
}

/* File Info */
.file-info {
    background-color: var(--color-bg-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    padding: var(--space-md);
    margin-bottom: var(--space-lg);
}

.file-details {
    display: flex;
    align-items: center;
    gap: var(--space-md);
}

.file-name {
    font-weight: 500;
    flex: 1;
}

.file-size {
    color: var(--color-text-muted);
    font-size: 0.875rem;
}

/* Column Mapping */
.column-mapping {
    background-color: var(--color-bg-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-xl);
    margin-bottom: var(--space-lg);
}

.mapping-instructions {
    color: var(--color-text-muted);
    margin-bottom: var(--space-lg);
}

.mapping-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-xl);
}

@media (max-width: 768px) {
    .mapping-grid {
        grid-template-columns: 1fr;
    }
}

.mapping-section h4 {
    border-bottom: 1px solid var(--color-border);
    padding-bottom: var(--space-sm);
    margin-bottom: var(--space-md);
}

.mapping-row {
    margin-bottom: var(--space-md);
}

.mapping-row label {
    font-size: 0.875rem;
}

.column-select {
    max-width: 100%;
}

.column-select.required {
    border-left: 3px solid var(--color-primary);
}

.dimension-instructions {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    margin-bottom: var(--space-sm);
}

.dimension-list {
    display: flex;
    flex-direction: column;
    gap: var(--space-xs);
}

/* Date Format Section */
.date-format-section {
    margin-top: var(--space-xl);
    padding-top: var(--space-xl);
    border-top: 1px solid var(--color-border);
}

.date-samples {
    list-style: none;
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-sm);
    margin-bottom: var(--space-md);
}

.date-samples li {
    background-color: var(--color-bg);
    padding: var(--space-xs) var(--space-sm);
    border-radius: var(--radius-sm);
    font-family: var(--font-mono);
    font-size: 0.875rem;
}

.date-format-confirm {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    flex-wrap: wrap;
}

.date-parse-preview {
    color: var(--color-success);
    font-size: 0.875rem;
    margin-bottom: 0;
}

.date-parse-preview.error {
    color: var(--color-error);
}

/* Screen Actions */
.screen-actions {
    margin-top: var(--space-xl);
    display: flex;
    justify-content: flex-end;
}

/* --------------------------------------------
   Screen 3: Periods
   -------------------------------------------- */
.period-config {
    background-color: var(--color-bg-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-xl);
}

.config-section {
    margin-bottom: var(--space-xl);
    padding-bottom: var(--space-xl);
    border-bottom: 1px solid var(--color-border);
}

.config-section:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
}

.config-section p {
    color: var(--color-text-muted);
    font-size: 0.875rem;
    margin-bottom: var(--space-sm);
}

.fy-select {
    max-width: 200px;
}

.date-input {
    max-width: 200px;
}

.date-range-info {
    background-color: var(--color-bg);
    padding: var(--space-md);
    border-radius: var(--radius-md);
}

.date-range-info p {
    margin-bottom: 0;
    color: var(--color-text);
}

.ltm-help {
    margin-top: var(--space-sm);
    font-size: 0.875rem;
}

.pfy-info {
    background-color: var(--color-bg);
    padding: var(--space-md);
    border-radius: var(--radius-md);
}

.pfy-info p {
    margin-bottom: 0;
}

.period-summary {
    margin-top: var(--space-xl);
    background-color: var(--color-primary-light);
    padding: var(--space-md);
    border-radius: var(--radius-md);
}

.period-summary p {
    margin-bottom: var(--space-xs);
}

.period-summary p:last-child {
    margin-bottom: 0;
}

/* --------------------------------------------
   Screen 4: Level of Detail
   -------------------------------------------- */
.lod-config {
    background-color: var(--color-bg-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-xl);
}

.lod-instructions {
    color: var(--color-text-muted);
    margin-bottom: var(--space-lg);
}

.lod-selection {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: var(--space-sm);
    margin-bottom: var(--space-lg);
}

.lod-warning {
    background-color: var(--color-warning-light);
    padding: var(--space-md);
    border-radius: var(--radius-md);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    margin-bottom: var(--space-lg);
}

.warning-icon {
    font-size: 1.25rem;
}

.warning-text {
    font-size: 0.875rem;
}

.lod-preview {
    background-color: var(--color-bg);
    padding: var(--space-md);
    border-radius: var(--radius-md);
    margin-bottom: var(--space-lg);
}

.lod-preview h4 {
    margin-bottom: var(--space-xs);
}

.lod-preview p {
    margin-bottom: 0;
    font-size: 0.875rem;
    color: var(--color-text-muted);
}

.gm-options {
    margin-top: var(--space-xl);
    padding-top: var(--space-xl);
    border-top: 1px solid var(--color-border);
}

/* --------------------------------------------
   Screen 5: Processing
   -------------------------------------------- */
#screen-processing .container {
    max-width: 600px;
    text-align: center;
}

.processing-status {
    background-color: var(--color-bg-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2xl);
}

.progress-container {
    margin-bottom: var(--space-xl);
}

.progress-bar {
    height: 12px;
    background-color: var(--color-bg);
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: var(--space-sm);
}

.progress-fill {
    height: 100%;
    background-color: var(--color-primary);
    width: 0%;
    transition: width 0.3s ease;
}

.progress-text {
    display: flex;
    justify-content: space-between;
    font-size: 0.875rem;
    color: var(--color-text-muted);
}

.processing-stages {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
    margin-bottom: var(--space-xl);
    text-align: left;
}

.stage {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-sm);
    border-radius: var(--radius-sm);
}

.stage.active {
    background-color: var(--color-primary-light);
}

.stage.complete .stage-icon::before {
    content: '‚úì';
}

.stage.complete {
    color: var(--color-success);
}

.stage-icon {
    width: 24px;
    text-align: center;
}

.processing-stats {
    background-color: var(--color-bg);
    padding: var(--space-md);
    border-radius: var(--radius-md);
    margin-bottom: var(--space-lg);
    font-size: 0.875rem;
    text-align: left;
}

/* --------------------------------------------
   Screen 6: Results
   -------------------------------------------- */
.results-tabs {
    display: flex;
    gap: var(--space-xs);
    border-bottom: 1px solid var(--color-border);
    margin-bottom: var(--space-xl);
    overflow-x: auto;
}

.tab-btn {
    background: none;
    padding: var(--space-md) var(--space-lg);
    border-radius: 0;
    border-bottom: 2px solid transparent;
    color: var(--color-text-muted);
    white-space: nowrap;
}

.tab-btn:hover {
    color: var(--color-text);
}

.tab-btn.active {
    color: var(--color-primary);
    border-bottom-color: var(--color-primary);
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

/* Summary Cards */
.summary-cards {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--space-md);
    margin-bottom: var(--space-xl);
}

@media (max-width: 768px) {
    .summary-cards {
        grid-template-columns: 1fr;
    }
}

.summary-card {
    background-color: var(--color-bg-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-xl);
    text-align: center;
    box-shadow: var(--shadow-md);
    transition: all 0.2s ease;
}

.summary-card:hover {
    box-shadow: var(--shadow-lg);
    transform: translateY(-2px);
}

.summary-card.highlight {
    background: linear-gradient(135deg, var(--color-primary-light) 0%, #FFFFFF 100%);
    border: 2px solid var(--color-primary);
    border-left-width: 4px;
}

.card-label {
    display: block;
    font-size: 0.875rem;
    color: var(--color-text-muted);
    margin-bottom: var(--space-sm);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 600;
}

.card-value {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    margin-bottom: var(--space-sm);
    color: var(--color-primary);
}

.card-period, .card-pct {
    display: block;
    font-size: 0.875rem;
    color: var(--color-text-muted);
}

.card-pct.positive {
    color: var(--color-positive);
}

.card-pct.negative {
    color: var(--color-negative);
}

/* Tables */
.bridge-table-container, .detail-table-container {
    background-color: var(--color-bg-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    overflow: hidden;
    box-shadow: var(--shadow-md);
    margin-bottom: var(--space-xl);
}

.bridge-table-container h3 {
    padding: var(--space-lg) var(--space-xl);
    border-bottom: 2px solid var(--color-border);
    margin-bottom: 0;
    background: linear-gradient(135deg, var(--color-primary-light) 0%, #FFFFFF 100%);
    color: var(--color-primary);
    font-weight: 700;
}

.bridge-chart-container {
    background-color: var(--color-bg-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    overflow: hidden;
    box-shadow: var(--shadow-md);
    margin-bottom: var(--space-xl);
    padding: var(--space-xl);
}

.bridge-chart-container h3 {
    margin-bottom: var(--space-lg);
    color: var(--color-primary);
    font-weight: 700;
}

table {
    width: 100%;
    border-collapse: collapse;
}

th, td {
    padding: var(--space-md) var(--space-lg);
    text-align: left;
    border-bottom: 1px solid var(--color-border);
}

th {
    background: linear-gradient(180deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
    font-weight: 600;
    font-size: 0.75rem;
    color: white;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    position: sticky;
    top: 0;
    z-index: 10;
}

th.num, td.num {
    text-align: right;
    font-family: var(--font-mono);
    font-size: 0.9375rem;
}

tbody tr {
    transition: background-color 0.15s ease;
}

tbody tr:hover {
    background-color: var(--color-primary-light);
}

tbody tr:last-child td {
    border-bottom: none;
}

.bridge-table .total-row {
    font-weight: 700;
    background-color: var(--color-primary-light);
    border-top: 2px solid var(--color-primary);
}

.positive {
    color: var(--color-positive);
}

.negative {
    color: var(--color-negative);
}

/* Detail Controls */
.detail-controls {
    display: flex;
    gap: var(--space-md);
    margin-bottom: var(--space-md);
    flex-wrap: wrap;
}

.search-box {
    flex: 1;
    min-width: 200px;
}

.search-box input {
    width: 100%;
    max-width: none;
}

.sort-controls {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
}

.sort-controls label {
    margin-bottom: 0;
    white-space: nowrap;
}

.detail-table-container {
    overflow-x: auto;
}

.detail-table {
    min-width: 800px;
}

/* Pagination */
.pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: var(--space-sm);
    margin-top: var(--space-lg);
}

.pagination button {
    padding: var(--space-sm) var(--space-md);
}

.pagination .page-info {
    color: var(--color-text-muted);
    font-size: 0.875rem;
}

/* Negatives Tab */
.negatives-explanation {
    background-color: var(--color-warning-light);
    padding: var(--space-md);
    border-radius: var(--radius-md);
    margin-bottom: var(--space-lg);
}

.negatives-explanation p {
    margin-bottom: 0;
}

.negatives-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--space-md);
    margin-bottom: var(--space-lg);
}

.negatives-table {
    background-color: var(--color-bg-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
}

/* Assumptions Tab */
.assumptions-content {
    background-color: var(--color-bg-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-xl);
}

.assumptions-content h3 {
    margin-top: var(--space-xl);
    padding-top: var(--space-xl);
    border-top: 1px solid var(--color-border);
}

.assumptions-content h3:first-child {
    margin-top: 0;
    padding-top: 0;
    border-top: none;
}

.assumptions-table {
    margin-bottom: var(--space-lg);
}

.assumptions-table th {
    width: 200px;
}

.methodology, .data-quality {
    font-size: 0.9375rem;
    line-height: 1.7;
}

.methodology ul, .data-quality ul {
    margin-left: var(--space-lg);
    margin-bottom: var(--space-md);
}

.methodology li, .data-quality li {
    margin-bottom: var(--space-xs);
}

.methodology code {
    background-color: var(--color-bg);
    padding: 2px 6px;
    border-radius: var(--radius-sm);
    font-family: var(--font-mono);
    font-size: 0.875rem;
}

/* --------------------------------------------
   Modal
   -------------------------------------------- */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal.hidden {
    display: none;
}

.modal-content {
    background-color: var(--color-bg-white);
    border-radius: var(--radius-lg);
    max-width: 500px;
    width: 90%;
    max-height: 90vh;
    overflow: auto;
}

.modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--space-lg);
    border-bottom: 1px solid var(--color-border);
}

.modal-header h3 {
    margin-bottom: 0;
}

.modal-close {
    background: none;
    font-size: 1.5rem;
    color: var(--color-text-muted);
    padding: 0;
}

.modal-close:hover {
    color: var(--color-text);
}

.modal-body {
    padding: var(--space-lg);
}

.modal-footer {
    padding: var(--space-lg);
    border-top: 1px solid var(--color-border);
    display: flex;
    justify-content: flex-end;
    gap: var(--space-sm);
}

/* --------------------------------------------
   Utility Classes
   -------------------------------------------- */
.hidden {
    display: none !important;
}

.text-muted {
    color: var(--color-text-muted);
}

.text-small {
    font-size: 0.875rem;
}

.mt-md {
    margin-top: var(--space-md);
}

.mb-md {
    margin-bottom: var(--space-md);
}

/* --------------------------------------------
   Print Styles
   -------------------------------------------- */
@media print {
    .screen {
        display: block !important;
        padding: 0;
    }

    .btn-back, .header-actions, .screen-actions, .detail-controls, .pagination {
        display: none !important;
    }

    .container {
        max-width: none;
    }

    table {
        font-size: 0.75rem;
    }
}
    </style>
</head>
<body>
    <div id="app">
        <!-- ============================================
             SCREEN 1: Landing / Disclaimer
             ============================================ -->
        <section id="screen-landing" class="screen active">
            <div class="container">
                <header class="landing-header">
                    <h1>Price‚ÄìVolume‚ÄìMix Bridge Tool</h1>
                    <p class="subtitle">Analyze revenue and margin drivers with full auditability</p>
                </header>

                <div class="disclaimer-box">
                    <h2>üîí 100% Local Processing</h2>
                    <ul>
                        <li><strong>No data leaves your computer.</strong> All processing happens in your browser.</li>
                        <li><strong>No internet required.</strong> Works offline after loading.</li>
                        <li><strong>No cloud, no APIs, no tracking.</strong> Your data stays yours.</li>
                        <li><strong>Auditable calculations.</strong> All formulas documented in output.</li>
                    </ul>
                    <p class="disclaimer-note">
                        This tool processes CSV files containing transaction-level data. 
                        Large files (GB-scale) are supported via streaming‚Äîyour computer's memory 
                        will not be overwhelmed.
                    </p>
                </div>

                <div class="mode-selection">
                    <h3>Select Analysis Mode</h3>
                    <div class="mode-buttons">
                        <button id="btn-mode-pvm" class="mode-btn selected" data-mode="pvm">
                            <span class="mode-icon">üìä</span>
                            <span class="mode-title">Sales PVM Bridge</span>
                            <span class="mode-desc">Price, Volume, Mix impact on Revenue</span>
                        </button>
                        <button id="btn-mode-gm" class="mode-btn" data-mode="gm">
                            <span class="mode-icon">üí∞</span>
                            <span class="mode-title">Gross Margin Bridge</span>
                            <span class="mode-desc">Margin drivers including Cost</span>
                        </button>
                    </div>
                </div>

                <button id="btn-start" class="btn-primary btn-large">
                    Get Started ‚Üí
                </button>
            </div>
        </section>

        <!-- ============================================
             SCREEN 2: File Upload & Column Mapping
             ============================================ -->
        <section id="screen-upload" class="screen">
            <div class="container">
                <header class="screen-header">
                    <button class="btn-back" data-target="screen-landing">‚Üê Back</button>
                    <h2>Step 1: Upload Your Data</h2>
                    <span class="mode-indicator" id="mode-indicator-upload"></span>
                </header>

                <div class="upload-area" id="upload-area">
                    <div class="upload-content">
                        <span class="upload-icon">üìÅ</span>
                        <p class="upload-text">Drag & drop your CSV or Excel file here</p>
                        <p class="upload-subtext">or click to browse (.csv, .xlsx, .xls)</p>
                        <input type="file" id="file-input" accept=".csv,.xlsx,.xls" hidden>
                    </div>
                </div>

                <div id="file-info" class="file-info hidden">
                    <div class="file-details">
                        <span class="file-name" id="file-name"></span>
                        <span class="file-size" id="file-size"></span>
                        <button class="btn-remove" id="btn-remove-file">‚úï</button>
                    </div>
                </div>

                <!-- Column Mapping Section -->
                <div id="column-mapping" class="column-mapping hidden">
                    <h3>Column Mapping</h3>
                    <p class="mapping-instructions">
                        We detected the following columns. Please confirm or adjust the mappings.
                    </p>

                    <div class="mapping-grid">
                        <div class="mapping-section required-mappings">
                            <h4>Required Columns</h4>
                            <div class="mapping-row">
                                <label for="map-date">Date</label>
                                <select id="map-date" data-field="date" class="column-select required"></select>
                            </div>
                            <div class="mapping-row">
                                <label for="map-sales">Sales (Revenue)</label>
                                <select id="map-sales" data-field="sales" class="column-select required"></select>
                            </div>
                            <div class="mapping-row">
                                <label for="map-quantity">Quantity (Volume)</label>
                                <select id="map-quantity" data-field="quantity" class="column-select required"></select>
                            </div>
                            <div class="mapping-row gm-only hidden">
                                <label for="map-cost">Cost</label>
                                <select id="map-cost" data-field="cost" class="column-select required"></select>
                            </div>
                        </div>

                        <div class="mapping-section dimension-mappings">
                            <h4>Dimension Columns (Optional)</h4>
                            <p class="dimension-instructions">Select columns to use as analysis dimensions</p>
                            <div id="dimension-checkboxes" class="dimension-list">
                                <!-- Populated dynamically -->
                            </div>
                        </div>
                    </div>

                    <!-- Date Format Confirmation -->
                    <div id="date-format-section" class="date-format-section hidden">
                        <h4>Date Format Detected</h4>
                        <div class="date-format-preview">
                            <p>Sample dates from your file:</p>
                            <ul id="date-samples" class="date-samples"></ul>
                        </div>
                        <div class="date-format-confirm">
                            <label for="date-format-select">Detected format:</label>
                            <select id="date-format-select">
                                <option value="auto">Auto-detect</option>
                                <option value="MM/DD/YYYY">MM/DD/YYYY</option>
                                <option value="DD/MM/YYYY">DD/MM/YYYY</option>
                                <option value="YYYY-MM-DD">YYYY-MM-DD</option>
                                <option value="DD-MMM-YYYY">DD-MMM-YYYY (e.g., 15-Jan-2024)</option>
                                <option value="MMM DD, YYYY">MMM DD, YYYY (e.g., Jan 15, 2024)</option>
                            </select>
                            <p id="date-parse-preview" class="date-parse-preview"></p>
                        </div>
                    </div>
                </div>

                <div class="screen-actions">
                    <button id="btn-to-periods" class="btn-primary" disabled>
                        Continue to Period Setup ‚Üí
                    </button>
                </div>
            </div>
        </section>

        <!-- ============================================
             SCREEN 3: Period Configuration
             ============================================ -->
        <section id="screen-periods" class="screen">
            <div class="container">
                <header class="screen-header">
                    <button class="btn-back" data-target="screen-upload">‚Üê Back</button>
                    <h2>Step 2: Configure Time Periods</h2>
                    <span class="mode-indicator" id="mode-indicator-periods"></span>
                </header>

                <div class="period-config">
                    <div class="config-section">
                        <h3>Fiscal Year End</h3>
                        <p>Which month does your fiscal year end?</p>
                        <select id="fy-end-month" class="fy-select">
                            <option value="1">January</option>
                            <option value="2">February</option>
                            <option value="3">March</option>
                            <option value="4">April</option>
                            <option value="5">May</option>
                            <option value="6">June</option>
                            <option value="7">July</option>
                            <option value="8">August</option>
                            <option value="9">September</option>
                            <option value="10">October</option>
                            <option value="11">November</option>
                            <option value="12" selected>December</option>
                        </select>
                    </div>

                    <div class="config-section">
                        <h3>Data Date Range</h3>
                        <div id="date-range-info" class="date-range-info">
                            <p>Scanning file to determine date range...</p>
                        </div>
                    </div>

                    <!-- Multi-Year Selection (shown when multiple complete years detected) -->
                    <div class="config-section" id="multi-year-section" style="display: none;">
                        <h3>Select Fiscal Years for Analysis</h3>
                        <p>Select which fiscal years to include in your multi-year analysis:</p>
                        <div id="fiscal-year-checkboxes" class="fiscal-year-selection">
                            <!-- Populated dynamically with fiscal year checkboxes -->
                        </div>
                        <p class="period-help" style="margin-top: 12px; font-size: 0.9em; color: var(--color-muted);">
                            Select at least 2 years to enable multi-year analysis.
                        </p>
                    </div>

                    <!-- Two-Period Configuration (shown when single year or user preference) -->
                    <div id="two-period-config">
                        <div class="config-section">
                            <h3>Current Period Type</h3>
                            <label class="checkbox-label">
                                <input type="checkbox" id="use-ltm-period" checked>
                                Use LTM (Last Twelve Months) for current period
                            </label>
                            <p class="period-help" style="margin-top: 8px; font-size: 0.9em; color: var(--color-muted);">
                                When unchecked, the current period will use a full fiscal year instead of LTM.
                            </p>
                        </div>

                        <div class="config-section" id="ltm-config-section">
                            <h3>LTM End Date</h3>
                            <p>Confirm the end date for Last Twelve Months calculation:</p>
                            <input type="date" id="ltm-end-date" class="date-input">
                            <p class="ltm-help">
                                LTM period will be: <span id="ltm-range-preview">--</span>
                            </p>
                        </div>

                        <div class="config-section" id="cy-fiscal-year-section" style="display: none;">
                            <h3>Current Fiscal Year</h3>
                            <p>Select the fiscal year for the current period:</p>
                            <input type="number" id="cy-fiscal-year" class="date-input" min="2000" max="2100" style="width: 120px;">
                            <p class="cy-help">
                                Current FY period will be: <span id="cy-range-preview">--</span>
                            </p>
                        </div>

                        <div class="config-section">
                            <h3>Prior Fiscal Year</h3>
                            <div id="pfy-info" class="pfy-info">
                                <p>Prior Fiscal Year: <span id="pfy-range">--</span></p>
                            </div>
                        </div>
                    </div>

                    <div class="period-summary" id="period-summary">
                        <!-- Populated after configuration -->
                    </div>
                </div>

                <div class="screen-actions">
                    <button id="btn-to-lod" class="btn-primary" disabled>
                        Continue to Level of Detail ‚Üí
                    </button>
                </div>
            </div>
        </section>

        <!-- ============================================
             SCREEN 4: Level of Detail Selection
             ============================================ -->
        <section id="screen-lod" class="screen">
            <div class="container">
                <header class="screen-header">
                    <button class="btn-back" data-target="screen-periods">‚Üê Back</button>
                    <h2>Step 3: Select Level of Detail</h2>
                    <span class="mode-indicator" id="mode-indicator-lod"></span>
                </header>

                <div class="lod-config">
                    <p class="lod-instructions">
                        Select which dimensions to include in your analysis. 
                        The bridge will be calculated at this level of detail.
                    </p>

                    <div class="lod-selection" id="lod-selection">
                        <!-- Populated with dimension checkboxes -->
                    </div>

                    <div id="lod-warning" class="lod-warning hidden">
                        <span class="warning-icon">‚ö†Ô∏è</span>
                        <span class="warning-text">
                            Selecting many dimensions may result in a large number of combinations.
                            Processing may take longer on large files.
                        </span>
                    </div>

                    <div class="lod-preview">
                        <h4>Analysis Preview</h4>
                        <p id="lod-preview-text">Select at least one dimension to see preview.</p>
                    </div>

                    <!-- GM-specific: Price Definition -->
                    <div id="gm-price-definition" class="gm-options hidden">
                        <h4>Gross Margin Price Definition</h4>
                        <div class="radio-group">
                            <label class="radio-option">
                                <input type="radio" name="gm-price-def" value="margin-per-unit" checked>
                                <span class="radio-label">
                                    <strong>Margin per Unit</strong>
                                    <span class="radio-desc">(Sales ‚àí Cost) / Quantity</span>
                                </span>
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="gm-price-def" value="sales-per-unit">
                                <span class="radio-label">
                                    <strong>Sales Price per Unit</strong>
                                    <span class="radio-desc">Sales / Quantity (Cost analyzed separately)</span>
                                </span>
                            </label>
                        </div>
                    </div>
                </div>

                <div class="screen-actions">
                    <button id="btn-process" class="btn-primary btn-large">
                        üöÄ Run Analysis
                    </button>
                </div>
            </div>
        </section>

        <!-- ============================================
             SCREEN 5: Processing
             ============================================ -->
        <section id="screen-processing" class="screen">
            <div class="container">
                <header class="screen-header">
                    <h2>Processing Your Data</h2>
                </header>

                <div class="processing-status">
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill"></div>
                        </div>
                        <div class="progress-text">
                            <span id="progress-percent">0%</span>
                            <span id="progress-rows">0 rows processed</span>
                        </div>
                    </div>

                    <div class="processing-stages">
                        <div class="stage" id="stage-parsing">
                            <span class="stage-icon">‚è≥</span>
                            <span class="stage-text">Parsing CSV</span>
                        </div>
                        <div class="stage" id="stage-aggregating">
                            <span class="stage-icon">‚è≥</span>
                            <span class="stage-text">Aggregating by LOD</span>
                        </div>
                        <div class="stage" id="stage-calculating">
                            <span class="stage-icon">‚è≥</span>
                            <span class="stage-text">Calculating Bridge</span>
                        </div>
                        <div class="stage" id="stage-finalizing">
                            <span class="stage-icon">‚è≥</span>
                            <span class="stage-text">Finalizing Results</span>
                        </div>
                    </div>

                    <div class="processing-stats" id="processing-stats">
                        <!-- Real-time stats -->
                    </div>

                    <button id="btn-cancel" class="btn-secondary">
                        Cancel Processing
                    </button>
                </div>
            </div>
        </section>

        <!-- ============================================
             SCREEN 6: Results
             ============================================ -->
        <section id="screen-results" class="screen">
            <div class="container wide">
                <header class="screen-header">
                    <button class="btn-back" data-target="screen-lod">‚Üê Adjust Settings</button>
                    <h2>Analysis Results</h2>
                    <div class="header-actions">
                        <button id="btn-export-excel" class="btn-primary">
                            üì• Export to Excel
                        </button>
                    </div>
                </header>

                <!-- Results Tabs -->
                <div class="results-tabs">
                    <button class="tab-btn active" data-tab="summary">Summary Bridge</button>
                    <button class="tab-btn" data-tab="detail">Detail by LOD</button>
                    <button class="tab-btn" data-tab="negatives">Negative Values</button>
                    <button class="tab-btn" data-tab="assumptions">Assumptions</button>
                </div>

                <!-- Tab: Summary Bridge -->
                <div class="tab-content active" id="tab-summary">
                    <div class="summary-cards">
                        <div class="summary-card">
                            <span class="card-label">Prior Year</span>
                            <span class="card-value" id="summary-py-value">--</span>
                            <span class="card-period" id="summary-py-period">--</span>
                        </div>
                        <div class="summary-card">
                            <span class="card-label">LTM</span>
                            <span class="card-value" id="summary-cy-value">--</span>
                            <span class="card-period" id="summary-cy-period">--</span>
                        </div>
                        <div class="summary-card highlight">
                            <span class="card-label">Change</span>
                            <span class="card-value" id="summary-change-value">--</span>
                            <span class="card-pct" id="summary-change-pct">--</span>
                        </div>
                    </div>

                    <div class="bridge-table-container">
                        <h3>Bridge Summary</h3>
                        <table class="bridge-table" id="bridge-summary-table">
                            <thead>
                                <tr>
                                    <th>Component</th>
                                    <th class="num">Impact</th>
                                    <th class="num">% of Change</th>
                                </tr>
                            </thead>
                            <tbody id="bridge-summary-body">
                                <!-- Populated dynamically -->
                            </tbody>
                        </table>
                    </div>

                    <div class="bridge-chart-container">
                        <h3>Bridge Waterfall Chart</h3>
                        <canvas id="bridge-chart" style="max-height: 400px;"></canvas>
                    </div>
                </div>

                <!-- Tab: Detail by LOD -->
                <div class="tab-content" id="tab-detail">
                    <div class="detail-controls">
                        <div class="search-box">
                            <input type="text" id="detail-search" placeholder="Search...">
                        </div>
                        <div class="sort-controls">
                            <label>Sort by:</label>
                            <select id="detail-sort">
                                <option value="total-desc">Total Impact (High to Low)</option>
                                <option value="total-asc">Total Impact (Low to High)</option>
                                <option value="price-desc">Price Impact (High to Low)</option>
                                <option value="volume-desc">Volume Impact (High to Low)</option>
                                <option value="mix-desc">Mix Impact (High to Low)</option>
                            </select>
                        </div>
                    </div>

                    <div class="detail-table-container">
                        <table class="detail-table" id="detail-table">
                            <thead id="detail-table-head">
                                <!-- Dynamic columns based on LOD -->
                            </thead>
                            <tbody id="detail-table-body">
                                <!-- Populated dynamically -->
                            </tbody>
                        </table>
                    </div>

                    <div class="pagination" id="detail-pagination">
                        <!-- Pagination controls -->
                    </div>
                </div>

                <!-- Tab: Negative Values -->
                <div class="tab-content" id="tab-negatives">
                    <div class="negatives-explanation">
                        <p>
                            Rows with Sales ‚â§ 0 or Quantity ‚â§ 0 are excluded from standard PVM calculations
                            and shown here separately. These may represent returns, adjustments, or data errors.
                        </p>
                    </div>

                    <div class="negatives-summary" id="negatives-summary">
                        <!-- Summary stats -->
                    </div>

                    <table class="negatives-table" id="negatives-table">
                        <thead>
                            <tr>
                                <th>Period</th>
                                <th>Type</th>
                                <th class="num">Count</th>
                                <th class="num">Total Sales</th>
                                <th class="num">Total Quantity</th>
                            </tr>
                        </thead>
                        <tbody id="negatives-table-body">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>

                <!-- Tab: Assumptions -->
                <div class="tab-content" id="tab-assumptions">
                    <div class="assumptions-content">
                        <h3>Analysis Configuration</h3>
                        <table class="assumptions-table">
                            <tbody id="assumptions-config">
                                <!-- Populated dynamically -->
                            </tbody>
                        </table>

                        <h3>Calculation Methodology</h3>
                        <div class="methodology" id="methodology-content">
                            <!-- Methodology explanation -->
                        </div>

                        <h3>Data Quality Notes</h3>
                        <div class="data-quality" id="data-quality-content">
                            <!-- Data quality notes -->
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- ============================================
             Error Modal
             ============================================ -->
        <div id="error-modal" class="modal hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>‚ö†Ô∏è Error</h3>
                    <button class="modal-close" id="error-modal-close">‚úï</button>
                </div>
                <div class="modal-body" id="error-modal-body">
                    <!-- Error message -->
                </div>
                <div class="modal-footer">
                    <button class="btn-primary" id="error-modal-ok">OK</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <script src="js/config.js"></script>
    <script src="js/period-utils.js"></script>
    <script src="js/csv-parser.js"></script>
    <script src="js/excel-parser.js"></script>
    <script src="js/aggregator.js"></script>
    <script src="js/bridge-calculator.js"></script>
    <script src="js/ui-renderer.js"></script>
    <script src="js/excel-export.js"></script>
    <script src="js/app.js"></script>
    <script src="js/app2.js"></script>

    <!-- Scripts -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <script>
// ============================================
// config.js
// ============================================
/**
 * ============================================
 * PVM Bridge Tool - Configuration
 * ============================================
 * 
 * Central configuration for column mappings,
 * validation rules, and processing settings.
 * 
 * All thresholds and defaults are auditable
 * and documented here for transparency.
 * ============================================
 */

const CONFIG = {
    // ----------------------------------------
    // Version & Metadata
    // ----------------------------------------
    VERSION: '1.0.0',
    APP_NAME: 'PVM & Gross Margin Bridge Tool',
    
    // ----------------------------------------
    // Processing Settings
    // ----------------------------------------
    CHUNK_SIZE: 1024 * 1024, // 1MB chunks for CSV streaming
    PROGRESS_UPDATE_INTERVAL: 100, // Update UI every N rows
    MAX_PREVIEW_ROWS: 5, // Rows to show for date format preview
    
    // ----------------------------------------
    // Column Detection Patterns
    // ----------------------------------------
    // These patterns help auto-detect column mappings
    // Order matters: first match wins
    COLUMN_PATTERNS: {
        date: [
            /^date$/i,
            /^transaction.?date$/i,
            /^invoice.?date$/i,
            /^order.?date$/i,
            /^sale.?date$/i,
            /date/i
        ],
        sales: [
            /^sales$/i,
            /^revenue$/i,
            /^net.?sales$/i,
            /^total.?sales$/i,
            /^amount$/i,
            /^sales.?amount$/i,
            /sales/i,
            /revenue/i
        ],
        quantity: [
            /^quantity$/i,
            /^qty$/i,
            /^volume$/i,
            /^units$/i,
            /^count$/i,
            /quantity/i,
            /volume/i
        ],
        cost: [
            /^cost$/i,
            /^cogs$/i,
            /^cost.?of.?goods$/i,
            /^total.?cost$/i,
            /^unit.?cost$/i,
            /cost/i
        ]
    },
    
    // ----------------------------------------
    // Date Format Detection
    // ----------------------------------------
    // Patterns for auto-detecting date formats
    DATE_FORMATS: [
        {
            id: 'YYYY-MM-DD',
            pattern: /^\d{4}-\d{2}-\d{2}$/,
            parse: (s) => {
                const [y, m, d] = s.split('-').map(Number);
                return new Date(y, m - 1, d);
            },
            example: '2024-01-15'
        },
        {
            id: 'MM/DD/YYYY',
            pattern: /^\d{1,2}\/\d{1,2}\/\d{4}$/,
            parse: (s) => {
                const [m, d, y] = s.split('/').map(Number);
                return new Date(y, m - 1, d);
            },
            example: '01/15/2024'
        },
        {
            id: 'DD/MM/YYYY',
            pattern: /^\d{1,2}\/\d{1,2}\/\d{4}$/,
            parse: (s) => {
                const [d, m, y] = s.split('/').map(Number);
                return new Date(y, m - 1, d);
            },
            example: '15/01/2024'
        },
        {
            id: 'MM-DD-YYYY',
            pattern: /^\d{1,2}-\d{1,2}-\d{4}$/,
            parse: (s) => {
                const [m, d, y] = s.split('-').map(Number);
                return new Date(y, m - 1, d);
            },
            example: '01-15-2024'
        },
        {
            id: 'DD-MMM-YYYY',
            pattern: /^\d{1,2}-[A-Za-z]{3}-\d{4}$/,
            parse: (s) => {
                const months = { jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5, jul: 6, aug: 7, sep: 8, oct: 9, nov: 10, dec: 11 };
                const parts = s.split('-');
                const d = parseInt(parts[0], 10);
                const m = months[parts[1].toLowerCase()];
                const y = parseInt(parts[2], 10);
                return new Date(y, m, d);
            },
            example: '15-Jan-2024'
        },
        {
            id: 'MMM DD, YYYY',
            pattern: /^[A-Za-z]{3}\s+\d{1,2},?\s+\d{4}$/,
            parse: (s) => {
                const months = { jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5, jul: 6, aug: 7, sep: 8, oct: 9, nov: 10, dec: 11 };
                const match = s.match(/([A-Za-z]{3})\s+(\d{1,2}),?\s+(\d{4})/);
                if (match) {
                    const m = months[match[1].toLowerCase()];
                    const d = parseInt(match[2], 10);
                    const y = parseInt(match[3], 10);
                    return new Date(y, m, d);
                }
                return null;
            },
            example: 'Jan 15, 2024'
        },
        {
            id: 'YYYYMMDD',
            pattern: /^\d{8}$/,
            parse: (s) => {
                const y = parseInt(s.substring(0, 4), 10);
                const m = parseInt(s.substring(4, 6), 10);
                const d = parseInt(s.substring(6, 8), 10);
                return new Date(y, m - 1, d);
            },
            example: '20240115'
        },
        {
            id: 'M/D/YYYY',
            pattern: /^\d{1,2}\/\d{1,2}\/\d{4}$/,
            parse: (s) => {
                const [m, d, y] = s.split('/').map(Number);
                return new Date(y, m - 1, d);
            },
            example: '1/5/2024'
        }
    ],
    
    // ----------------------------------------
    // Month Names (for display)
    // ----------------------------------------
    MONTH_NAMES: [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
    ],
    
    MONTH_NAMES_SHORT: [
        'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ],
    
    // ----------------------------------------
    // Validation Rules
    // ----------------------------------------
    VALIDATION: {
        // Rows with sales <= 0 OR quantity <= 0 are excluded from PVM math
        // These are tracked separately as "negative values"
        MIN_SALES_FOR_PVM: 0,
        MIN_QUANTITY_FOR_PVM: 0,
        
        // Maximum dimensions allowed (soft limit, warning only)
        MAX_RECOMMENDED_DIMENSIONS: 4,
        
        // Warn if estimated combinations exceed this
        MAX_RECOMMENDED_COMBINATIONS: 100000
    },
    
    // ----------------------------------------
    // Default Values
    // ----------------------------------------
    DEFAULTS: {
        FISCAL_YEAR_END_MONTH: 12, // December
        UNKNOWN_DIMENSION_VALUE: 'Unknown',
        
        // GM mode price definition
        GM_PRICE_DEFINITION: 'margin-per-unit' // or 'sales-per-unit'
    },
    
    // ----------------------------------------
    // Number Formatting
    // ----------------------------------------
    FORMAT: {
        // Decimal places for different values
        DECIMALS_CURRENCY: 2,
        DECIMALS_QUANTITY: 0,
        DECIMALS_PRICE: 4,
        DECIMALS_PERCENT: 1,
        
        // Thousand separator
        THOUSAND_SEP: ',',
        DECIMAL_SEP: '.'
    },
    
    // ----------------------------------------
    // Local Storage Keys
    // ----------------------------------------
    STORAGE_KEYS: {
        LAST_CONFIG: 'pvm_bridge_last_config',
        PREFERENCES: 'pvm_bridge_preferences'
    },
    
    // ----------------------------------------
    // Excel Export Settings
    // ----------------------------------------
    EXCEL: {
        // Tab names for export
        TAB_NAMES: {
            SUMMARY: 'Summary Bridge',
            DETAIL: 'Detail by LOD',
            NEGATIVES: 'Negative Values',
            ASSUMPTIONS: 'Assumptions'
        },
        
        // Column widths (in characters)
        COL_WIDTH_DEFAULT: 15,
        COL_WIDTH_DIMENSION: 20,
        COL_WIDTH_NUMBER: 18
    }
};

// Freeze config to prevent accidental modification
Object.freeze(CONFIG);
Object.freeze(CONFIG.COLUMN_PATTERNS);
Object.freeze(CONFIG.VALIDATION);
Object.freeze(CONFIG.DEFAULTS);
Object.freeze(CONFIG.FORMAT);
Object.freeze(CONFIG.STORAGE_KEYS);
Object.freeze(CONFIG.EXCEL);
Object.freeze(CONFIG.EXCEL.TAB_NAMES);

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CONFIG;
}

// ============================================
// period-utils.js
// ============================================
/**
 * ============================================
 * PVM Bridge Tool - Period Utilities
 * ============================================
 * 
 * Handles all date and period logic:
 * - Fiscal year calculations
 * - LTM (Last Twelve Months) range determination
 * - Period classification (PY vs CY/LTM)
 * - Date format detection and parsing
 * 
 * All calculations are deterministic and auditable.
 * ============================================
 */

const PeriodUtils = {
    /**
     * Detect date format from sample values
     * Returns the most likely format based on pattern matching
     * 
     * @param {string[]} samples - Array of date strings to analyze
     * @returns {Object} - { formatId, confidence, parser }
     */
    detectDateFormat: function(samples) {
        if (!samples || samples.length === 0) {
            return { formatId: null, confidence: 0, parser: null };
        }

        // Filter out empty/null values
        const validSamples = samples.filter(s => s && s.trim());
        if (validSamples.length === 0) {
            return { formatId: null, confidence: 0, parser: null };
        }

        // Try each format and count matches
        const formatScores = {};
        
        for (const format of CONFIG.DATE_FORMATS) {
            let matches = 0;
            let validDates = 0;
            
            for (const sample of validSamples) {
                const trimmed = sample.trim();
                if (format.pattern.test(trimmed)) {
                    matches++;
                    // Also verify it parses to a valid date
                    try {
                        const parsed = format.parse(trimmed);
                        if (parsed && !isNaN(parsed.getTime())) {
                            // Sanity check: year should be reasonable (1900-2100)
                            const year = parsed.getFullYear();
                            if (year >= 1900 && year <= 2100) {
                                validDates++;
                            }
                        }
                    } catch (e) {
                        // Parse failed, don't count as valid
                    }
                }
            }
            
            formatScores[format.id] = {
                matches: matches,
                validDates: validDates,
                score: validDates / validSamples.length
            };
        }

        // Find best format
        let bestFormat = null;
        let bestScore = 0;
        
        for (const format of CONFIG.DATE_FORMATS) {
            const score = formatScores[format.id];
            if (score.score > bestScore) {
                bestScore = score.score;
                bestFormat = format;
            }
        }

        // Handle MM/DD/YYYY vs DD/MM/YYYY ambiguity
        // If both match, check if any values have day > 12
        if (bestFormat && (bestFormat.id === 'MM/DD/YYYY' || bestFormat.id === 'DD/MM/YYYY')) {
            const mmddScore = formatScores['MM/DD/YYYY'];
            const ddmmScore = formatScores['DD/MM/YYYY'];
            
            if (mmddScore && ddmmScore && 
                Math.abs(mmddScore.score - ddmmScore.score) < 0.1) {
                // Ambiguous - look for values that disambiguate
                for (const sample of validSamples) {
                    const parts = sample.split('/');
                    if (parts.length === 3) {
                        const first = parseInt(parts[0], 10);
                        const second = parseInt(parts[1], 10);
                        
                        // If first part > 12, it must be day (DD/MM/YYYY)
                        if (first > 12 && first <= 31) {
                            bestFormat = CONFIG.DATE_FORMATS.find(f => f.id === 'DD/MM/YYYY');
                            break;
                        }
                        // If second part > 12, it must be day (MM/DD/YYYY)
                        if (second > 12 && second <= 31) {
                            bestFormat = CONFIG.DATE_FORMATS.find(f => f.id === 'MM/DD/YYYY');
                            break;
                        }
                    }
                }
            }
        }

        return {
            formatId: bestFormat ? bestFormat.id : null,
            confidence: bestScore,
            parser: bestFormat ? bestFormat.parse : null,
            format: bestFormat
        };
    },

    /**
     * Parse a date string using a specific format
     * 
     * @param {string} dateStr - Date string to parse
     * @param {string} formatId - Format ID (e.g., 'YYYY-MM-DD')
     * @returns {Date|null} - Parsed date or null if invalid
     */
    parseDate: function(dateStr, formatId) {
        if (!dateStr || !formatId) return null;
        
        const format = CONFIG.DATE_FORMATS.find(f => f.id === formatId);
        if (!format) {
            // Try auto-detect if format not found
            const detected = this.detectDateFormat([dateStr]);
            if (detected.parser) {
                return detected.parser(dateStr.trim());
            }
            return null;
        }
        
        try {
            const parsed = format.parse(dateStr.trim());
            if (parsed && !isNaN(parsed.getTime())) {
                return parsed;
            }
        } catch (e) {
            // Parse failed
        }
        
        return null;
    },

    /**
     * Calculate fiscal year for a given date
     * 
     * @param {Date} date - The date to classify
     * @param {number} fyEndMonth - Month when FY ends (1-12)
     * @returns {number} - Fiscal year (e.g., 2024)
     * 
     * Example: If FY ends in June (6), then:
     * - July 2023 -> FY 2024
     * - June 2024 -> FY 2024
     * - July 2024 -> FY 2025
     */
    getFiscalYear: function(date, fyEndMonth) {
        const month = date.getMonth() + 1; // 1-12
        const year = date.getFullYear();
        
        if (month > fyEndMonth) {
            // After FY end, belongs to next FY
            return year + 1;
        } else {
            // On or before FY end, belongs to current calendar year's FY
            return year;
        }
    },

    /**
     * Get fiscal year start and end dates
     * 
     * @param {number} fiscalYear - The fiscal year (e.g., 2024)
     * @param {number} fyEndMonth - Month when FY ends (1-12)
     * @returns {Object} - { start: Date, end: Date }
     * 
     * Example: FY 2024 with June year-end:
     * - Start: July 1, 2023
     * - End: June 30, 2024
     */
    getFiscalYearRange: function(fiscalYear, fyEndMonth) {
        let startYear, startMonth, endYear, endMonth;
        
        if (fyEndMonth === 12) {
            // Calendar year = fiscal year
            startYear = fiscalYear;
            startMonth = 1;
            endYear = fiscalYear;
            endMonth = 12;
        } else {
            // FY starts in month after FY end, previous calendar year
            startYear = fiscalYear - 1;
            startMonth = fyEndMonth + 1;
            endYear = fiscalYear;
            endMonth = fyEndMonth;
        }
        
        // Get last day of end month
        const endDate = new Date(endYear, endMonth, 0); // Day 0 = last day of previous month
        
        return {
            start: new Date(startYear, startMonth - 1, 1),
            end: endDate
        };
    },

    /**
     * Get LTM (Last Twelve Months) range ending on a specific date
     * 
     * @param {Date} endDate - LTM end date
     * @returns {Object} - { start: Date, end: Date }
     */
    getLTMRange: function(endDate) {
        // LTM starts 12 months before end date
        const start = new Date(endDate);
        start.setFullYear(start.getFullYear() - 1);
        start.setDate(start.getDate() + 1); // Day after to make it exactly 12 months
        
        return {
            start: start,
            end: new Date(endDate)
        };
    },

    /**
     * Determine prior fiscal year based on LTM end date
     * 
     * @param {Date} ltmEndDate - End date of LTM period
     * @param {number} fyEndMonth - Month when FY ends (1-12)
     * @returns {number} - Prior fiscal year number
     */
    getPriorFiscalYear: function(ltmEndDate, fyEndMonth) {
        const ltmFY = this.getFiscalYear(ltmEndDate, fyEndMonth);
        return ltmFY - 1;
    },

    /**
     * Classify a date into period: 'PY', 'CY', or null (outside both)
     * 
     * @param {Date} date - Date to classify
     * @param {Object} pyRange - { start: Date, end: Date } for Prior Year
     * @param {Object} cyRange - { start: Date, end: Date } for Current Year/LTM
     * @returns {string|null} - 'PY', 'CY', or null
     */
    classifyPeriod: function(date, pyRange, cyRange) {
        const time = date.getTime();
        
        if (time >= pyRange.start.getTime() && time <= pyRange.end.getTime()) {
            return 'PY';
        }
        
        if (time >= cyRange.start.getTime() && time <= cyRange.end.getTime()) {
            return 'CY';
        }
        
        return null;
    },

    /**
     * Format a date for display
     * 
     * @param {Date} date - Date to format
     * @param {string} style - 'short', 'medium', or 'long'
     * @returns {string} - Formatted date string
     */
    formatDate: function(date, style = 'medium') {
        if (!date || isNaN(date.getTime())) return '--';
        
        const day = date.getDate();
        const month = date.getMonth();
        const year = date.getFullYear();
        
        switch (style) {
            case 'short':
                return `${month + 1}/${day}/${year}`;
            case 'long':
                return `${CONFIG.MONTH_NAMES[month]} ${day}, ${year}`;
            case 'medium':
            default:
                return `${CONFIG.MONTH_NAMES_SHORT[month]} ${day}, ${year}`;
        }
    },

    /**
     * Format a date range for display
     * 
     * @param {Date} start - Start date
     * @param {Date} end - End date
     * @returns {string} - Formatted range string
     */
    formatDateRange: function(start, end) {
        return `${this.formatDate(start)} - ${this.formatDate(end)}`;
    },

    /**
     * Convert Date to ISO date string (YYYY-MM-DD) for input[type="date"]
     * 
     * @param {Date} date - Date to convert
     * @returns {string} - ISO date string
     */
    toISODateString: function(date) {
        if (!date || isNaN(date.getTime())) return '';
        
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        
        return `${year}-${month}-${day}`;
    },

    /**
     * Parse ISO date string (YYYY-MM-DD) from input[type="date"]
     * 
     * @param {string} isoString - ISO date string
     * @returns {Date|null} - Parsed date
     */
    fromISODateString: function(isoString) {
        if (!isoString) return null;
        
        const parts = isoString.split('-');
        if (parts.length !== 3) return null;
        
        const year = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1;
        const day = parseInt(parts[2], 10);
        
        const date = new Date(year, month, day);
        if (isNaN(date.getTime())) return null;
        
        return date;
    },

    /**
     * Check if two dates are the same day
     * 
     * @param {Date} date1 - First date
     * @param {Date} date2 - Second date
     * @returns {boolean}
     */
    isSameDay: function(date1, date2) {
        return date1.getFullYear() === date2.getFullYear() &&
               date1.getMonth() === date2.getMonth() &&
               date1.getDate() === date2.getDate();
    },

    /**
     * Get the last day of a month
     * 
     * @param {number} year - Year
     * @param {number} month - Month (1-12)
     * @returns {Date}
     */
    getLastDayOfMonth: function(year, month) {
        // Day 0 of next month = last day of current month
        return new Date(year, month, 0);
    },

    /**
     * Validate period configuration
     * Returns warnings/errors for the user
     * 
     * @param {Object} config - { fyEndMonth, ltmEndDate, pyRange, cyRange }
     * @returns {Object} - { valid: boolean, warnings: string[], errors: string[] }
     */
    validatePeriodConfig: function(config) {
        const warnings = [];
        const errors = [];
        
        // Check if LTM end date is valid
        if (!config.ltmEndDate || isNaN(config.ltmEndDate.getTime())) {
            errors.push('LTM end date is invalid.');
        }
        
        // Check if periods overlap
        if (config.pyRange && config.cyRange) {
            if (config.pyRange.end >= config.cyRange.start) {
                warnings.push('Prior Year and LTM periods overlap. Some data may be counted in both periods.');
            }
            
            // Check gap between periods
            const gapDays = (config.cyRange.start - config.pyRange.end) / (1000 * 60 * 60 * 24);
            if (gapDays > 365) {
                warnings.push(`There is a ${Math.round(gapDays)} day gap between Prior Year and LTM. Some data may be excluded.`);
            }
        }
        
        return {
            valid: errors.length === 0,
            warnings: warnings,
            errors: errors
        };
    },

    /**
     * Detect all complete fiscal years in a date range
     *
     * @param {Date} minDate - Earliest date in dataset
     * @param {Date} maxDate - Latest date in dataset
     * @param {number} fyEndMonth - Fiscal year end month (1-12)
     * @returns {Object[]} - Array of fiscal year objects with metadata
     */
    detectFiscalYears: function(minDate, maxDate, fyEndMonth) {
        if (!minDate || !maxDate || !fyEndMonth) {
            return [];
        }

        const fiscalYears = [];

        // Get first fiscal year that minDate falls into
        const minYear = minDate.getFullYear();
        const minMonth = minDate.getMonth() + 1; // 1-12
        let startFY = minMonth > fyEndMonth ? minYear + 1 : minYear;

        // Get last fiscal year that maxDate falls into
        const maxYear = maxDate.getFullYear();
        const maxMonth = maxDate.getMonth() + 1;
        let endFY = maxMonth > fyEndMonth ? maxYear + 1 : maxYear;

        // Generate fiscal year data for each year in range
        for (let fy = startFY; fy <= endFY; fy++) {
            const fyRange = this.getFiscalYearRange(fy, fyEndMonth);

            // Check if this FY has complete data coverage
            // Only include if the data range covers the entire FY
            const fyFullyCovered = minDate <= fyRange.start && maxDate >= fyRange.end;

            // Always include the year, but flag if not fully covered
            fiscalYears.push({
                fiscalYear: fy,
                label: `FY ${fy}`,
                start: fyRange.start,
                end: fyRange.end,
                fullyCovered: fyFullyCovered
            });
        }

        return fiscalYears;
    },

    /**
     * Check if data range has multiple complete fiscal years
     *
     * @param {Date} minDate - Earliest date
     * @param {Date} maxDate - Latest date
     * @param {number} fyEndMonth - Fiscal year end month
     * @returns {boolean} - True if 2+ complete fiscal years detected
     */
    hasMultipleYears: function(minDate, maxDate, fyEndMonth) {
        const years = this.detectFiscalYears(minDate, maxDate, fyEndMonth);
        return years.filter(y => y.fullyCovered).length >= 2;
    }
};

// Export for use in other modules and web worker
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PeriodUtils;
}

// ============================================
// csv-parser.js
// ============================================
/**
 * ============================================
 * PVM Bridge Tool - CSV Parser
 * ============================================
 * 
 * Streaming CSV parser designed for large files.
 * Key features:
 * - Chunked reading (never loads full file)
 * - Handles quoted fields with embedded commas/newlines
 * - Memory-efficient processing
 * - Progress callbacks for UI updates
 * ============================================
 */

const CSVParser = {
    /**
     * Parse a CSV file in streaming chunks
     */
    parseFile: async function(file, options) {
        const {
            onRow,
            onProgress,
            onHeaders,
            onComplete,
            onError,
            shouldCancel = () => false,
            chunkSize = CONFIG.CHUNK_SIZE
        } = options;

        const totalBytes = file.size;
        let bytesRead = 0;
        let rowCount = 0;
        let headers = null;
        let buffer = '';

        try {
            const reader = file.stream().getReader();
            const decoder = new TextDecoder('utf-8');

            while (true) {
                if (shouldCancel()) {
                    onComplete && onComplete({ cancelled: true, rowCount });
                    return;
                }

                const { done, value } = await reader.read();
                
                if (done) {
                    if (buffer.length > 0) {
                        const finalRows = this._extractCompleteRows(buffer + '\n').rows;
                        for (const row of finalRows) {
                            if (!headers) {
                                headers = row;
                                onHeaders && onHeaders(headers);
                            } else {
                                rowCount++;
                                onRow && onRow(this._rowToObject(row, headers), rowCount);
                            }
                        }
                    }
                    break;
                }

                const chunk = decoder.decode(value, { stream: true });
                bytesRead += value.length;
                buffer += chunk;

                const { rows, remainder } = this._extractCompleteRows(buffer);
                buffer = remainder;

                for (const row of rows) {
                    if (!headers) {
                        headers = row;
                        onHeaders && onHeaders(headers);
                    } else {
                        rowCount++;
                        onRow && onRow(this._rowToObject(row, headers), rowCount);
                        
                        if (rowCount % CONFIG.PROGRESS_UPDATE_INTERVAL === 0) {
                            onProgress && onProgress(bytesRead, totalBytes, rowCount);
                        }
                    }
                }

                onProgress && onProgress(bytesRead, totalBytes, rowCount);
            }

            onComplete && onComplete({ cancelled: false, rowCount, headers });

        } catch (error) {
            onError && onError(error);
        }
    },

    /**
     * Extract complete CSV rows from buffer
     * @private
     */
    _extractCompleteRows: function(buffer) {
        const rows = [];
        let currentRow = [];
        let currentField = '';
        let inQuotes = false;
        let i = 0;

        while (i < buffer.length) {
            const char = buffer[i];
            const nextChar = buffer[i + 1];

            if (inQuotes) {
                if (char === '"') {
                    if (nextChar === '"') {
                        currentField += '"';
                        i += 2;
                        continue;
                    } else {
                        inQuotes = false;
                        i++;
                        continue;
                    }
                } else {
                    currentField += char;
                    i++;
                    continue;
                }
            }

            if (char === '"') {
                inQuotes = true;
                i++;
                continue;
            }

            if (char === ',') {
                currentRow.push(currentField.trim());
                currentField = '';
                i++;
                continue;
            }

            if (char === '\r') {
                if (nextChar === '\n') i++;
                currentRow.push(currentField.trim());
                if (currentRow.length > 0 && !(currentRow.length === 1 && currentRow[0] === '')) {
                    rows.push(currentRow);
                }
                currentRow = [];
                currentField = '';
                i++;
                continue;
            }

            if (char === '\n') {
                currentRow.push(currentField.trim());
                if (currentRow.length > 0 && !(currentRow.length === 1 && currentRow[0] === '')) {
                    rows.push(currentRow);
                }
                currentRow = [];
                currentField = '';
                i++;
                continue;
            }

            currentField += char;
            i++;
        }

        let remainder = '';
        if (currentField || currentRow.length > 0) {
            currentRow.push(currentField);
            remainder = this._reconstructRow(currentRow, inQuotes);
        }

        return { rows, remainder };
    },

    _reconstructRow: function(row, inQuotes) {
        let result = row.map(f => {
            if (f.includes(',') || f.includes('"') || f.includes('\n')) {
                return '"' + f.replace(/"/g, '""') + '"';
            }
            return f;
        }).join(',');
        
        if (inQuotes) {
            const lastComma = result.lastIndexOf(',');
            if (lastComma >= 0) {
                result = result.substring(0, lastComma + 1) + '"' + result.substring(lastComma + 1);
            } else {
                result = '"' + result;
            }
        }
        return result;
    },

    _rowToObject: function(row, headers) {
        const obj = {};
        for (let i = 0; i < headers.length; i++) {
            obj[headers[i]] = row[i] !== undefined ? row[i] : '';
        }
        return obj;
    },

    /**
     * Quick scan of file to get headers and sample rows
     */
    scanFile: async function(file, maxRows = 100) {
        return new Promise((resolve, reject) => {
            const headers = [];
            const sampleRows = [];

            this.parseFile(file, {
                onHeaders: (h) => headers.push(...h),
                onRow: (row) => {
                    if (sampleRows.length < maxRows) sampleRows.push(row);
                },
                shouldCancel: () => sampleRows.length >= maxRows,
                onComplete: () => resolve({ headers, sampleRows }),
                onError: reject
            });
        });
    },

    /**
     * Detect column types from sample data
     */
    detectColumnMappings: function(headers, sampleRows) {
        const mappings = { date: null, sales: null, quantity: null, cost: null, dimensions: [] };
        const usedColumns = new Set();

        for (const field of ['date', 'sales', 'quantity', 'cost']) {
            const patterns = CONFIG.COLUMN_PATTERNS[field];
            for (const pattern of patterns) {
                for (const header of headers) {
                    if (!usedColumns.has(header) && pattern.test(header)) {
                        mappings[field] = header;
                        usedColumns.add(header);
                        break;
                    }
                }
                if (mappings[field]) break;
            }
        }

        for (const header of headers) {
            if (!usedColumns.has(header)) {
                const isNumeric = sampleRows.every(row => {
                    const val = row[header];
                    if (!val || val === '') return true;
                    return !isNaN(parseFloat(String(val).replace(/[,$]/g, '')));
                });
                if (!isNumeric) mappings.dimensions.push(header);
            }
        }

        return mappings;
    },

    extractDateSamples: function(sampleRows, dateColumn) {
        const samples = new Set();
        for (const row of sampleRows) {
            const value = row[dateColumn];
            if (value && value.trim()) {
                samples.add(value.trim());
                if (samples.size >= CONFIG.MAX_PREVIEW_ROWS) break;
            }
        }
        return Array.from(samples);
    },

    parseNumber: function(value) {
        if (value === null || value === undefined || value === '') return NaN;
        
        let str = String(value).trim();
        const isNegative = str.startsWith('(') && str.endsWith(')');
        if (isNegative) str = str.slice(1, -1);
        
        str = str.replace(/[$‚Ç¨¬£¬•,]/g, '');
        const hasMinusSign = str.startsWith('-');
        if (hasMinusSign) str = str.slice(1);
        
        const num = parseFloat(str);
        if (isNaN(num)) return NaN;
        
        return (isNegative || hasMinusSign) ? -num : num;
    }
};

if (typeof module !== 'undefined' && module.exports) {
    module.exports = CSVParser;
}

// ============================================
// excel-parser.js
// ============================================
/**
 * ============================================
 * PVM Bridge Tool - Excel Parser
 * ============================================
 *
 * Parses Excel files (.xlsx, .xls) using SheetJS.
 * Converts Excel data to same format as CSV parser for compatibility.
 * ============================================
 */

const ExcelParser = {
    /**
     * Convert row array to object keyed by headers
     * @private
     */
    _rowToObject: function(row, headers) {
        const obj = {};
        for (let i = 0; i < headers.length; i++) {
            obj[headers[i]] = row[i] !== undefined ? String(row[i]) : '';
        }
        return obj;
    },

    /**
     * Scan Excel file and extract headers + sample rows
     * @param {File} file - Excel file
     * @param {number} sampleSize - Number of rows to sample
     * @returns {Promise<{headers: string[], sampleRows: Object[]}>}
     */
    scanFile: async function(file, sampleSize = 100) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();

            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });

                    // Use first sheet
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];

                    // Convert to array of arrays
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

                    if (jsonData.length === 0) {
                        reject(new Error('Excel file is empty'));
                        return;
                    }

                    // First row is headers
                    const headers = jsonData[0].map(h => String(h).trim());

                    // Rest are data rows (up to sampleSize) - convert to objects
                    const sampleRows = jsonData.slice(1, sampleSize + 1).map(row => {
                        const rowArray = row.map(cell => String(cell));
                        return this._rowToObject(rowArray, headers);
                    });

                    resolve({ headers, sampleRows });
                } catch (error) {
                    reject(new Error('Failed to parse Excel file: ' + error.message));
                }
            };

            reader.onerror = function() {
                reject(new Error('Failed to read Excel file'));
            };

            reader.readAsArrayBuffer(file);
        });
    },

    /**
     * Parse entire Excel file in chunks (for large files)
     * Converts to row-by-row format compatible with CSV parser
     */
    parseFile: async function(file, options) {
        const {
            onRow,
            onProgress,
            onHeaders,
            onComplete,
            onError,
            shouldCancel = () => false
        } = options;

        try {
            const reader = new FileReader();

            reader.onload = (e) => {
                try {
                    if (shouldCancel()) {
                        onComplete && onComplete({ cancelled: true, rowCount: 0 });
                        return;
                    }

                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });

                    // Use first sheet
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];

                    // Convert to array of arrays
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

                    if (jsonData.length === 0) {
                        onError && onError(new Error('Excel file is empty'));
                        return;
                    }

                    // First row is headers
                    const headers = jsonData[0].map(h => String(h).trim());
                    onHeaders && onHeaders(headers);

                    // Process data rows
                    let rowCount = 0;
                    for (let i = 1; i < jsonData.length; i++) {
                        if (shouldCancel()) {
                            onComplete && onComplete({ cancelled: true, rowCount });
                            return;
                        }

                        const rowArray = jsonData[i].map(cell => String(cell));
                        const rowObj = this._rowToObject(rowArray, headers);
                        onRow && onRow(rowObj, i);
                        rowCount++;

                        // Simulate progress (Excel is loaded all at once, but we can still report progress)
                        if (rowCount % 1000 === 0 && onProgress) {
                            const progressBytes = Math.floor((i / jsonData.length) * file.size);
                            onProgress(progressBytes, file.size, rowCount);
                        }
                    }

                    // Final progress
                    onProgress && onProgress(file.size, file.size, rowCount);
                    onComplete && onComplete({ cancelled: false, rowCount });

                } catch (error) {
                    onError && onError(new Error('Failed to parse Excel file: ' + error.message));
                }
            };

            reader.onerror = function() {
                onError && onError(new Error('Failed to read Excel file'));
            };

            reader.readAsArrayBuffer(file);

        } catch (error) {
            onError && onError(error);
        }
    },

    /**
     * Extract date samples from Excel data
     */
    extractDateSamples: function(sampleRows, dateColumn) {
        const samples = new Set();
        for (const row of sampleRows) {
            const value = row[dateColumn];
            if (value && value.trim && value.trim()) {
                samples.add(value.trim());
                if (samples.size >= 10) break;
            }
        }
        return Array.from(samples);
    },

    /**
     * Check if file is an Excel file
     */
    isExcelFile: function(filename) {
        const lower = filename.toLowerCase();
        return lower.endsWith('.xlsx') || lower.endsWith('.xls');
    }
};

// ============================================
// aggregator.js
// ============================================
/**
 * ============================================
 * PVM Bridge Tool - Aggregator
 * ============================================
 * 
 * Incremental aggregation engine.
 * Accumulates data by LOD combination without
 * storing individual rows.
 * 
 * Memory-efficient: only stores unique LOD keys
 * plus their aggregated values.
 * ============================================
 */

const Aggregator = {
    /**
     * Create a new aggregation context
     *
     * @param {Object} config - Aggregation configuration
     * @param {string[]} config.dimensions - Dimension columns for LOD
     * @param {string} config.dateColumn - Date column name
     * @param {string} config.salesColumn - Sales column name
     * @param {string} config.quantityColumn - Quantity column name
     * @param {string} config.costColumn - Cost column name (optional, for GM mode)
     * @param {string} config.dateFormat - Date format ID
     * @param {Object} config.pyRange - Prior year date range { start, end } (two-period mode)
     * @param {Object} config.cyRange - Current year/LTM date range { start, end } (two-period mode)
     * @param {Object[]} config.fiscalYears - Array of fiscal year configs (multi-year mode)
     * @param {number} config.fyEndMonth - Fiscal year end month (multi-year mode)
     * @returns {Object} - Aggregation context
     */
    createContext: function(config) {
        // Detect mode: multi-year or two-period
        const isMultiYear = config.fiscalYears && config.fiscalYears.length > 0;

        // Build period lookup for multi-year mode
        let yearLookup = null;
        if (isMultiYear) {
            yearLookup = config.fiscalYears.map(fy => ({
                fy: fy.fiscalYear,
                start: fy.start,
                end: fy.end,
                label: fy.label
            }));
        }

        return {
            config: config,
            isMultiYear: isMultiYear,
            yearLookup: yearLookup,

            // Main aggregation map: LOD key -> { years: {2016: {...}, 2017: {...}} } or { py: {...}, cy: {...} }
            data: new Map(),

            // Negative values tracking (by year for multi-year, by py/cy for two-period)
            negatives: isMultiYear ? {} : {
                py: { count: 0, sales: 0, quantity: 0, cost: 0 },
                cy: { count: 0, sales: 0, quantity: 0, cost: 0 }
            },

            // Statistics
            stats: {
                totalRows: 0,
                includedRows: 0,
                excludedRows: 0,
                pyRows: isMultiYear ? undefined : 0,
                cyRows: isMultiYear ? undefined : 0,
                yearRows: isMultiYear ? {} : undefined,
                outsidePeriodRows: 0,
                parseErrors: 0,
                uniqueLODKeys: 0
            },

            // Date range tracking
            dateRange: {
                min: null,
                max: null
            }
        };
    },

    /**
     * Process a single row and update aggregation
     * 
     * @param {Object} ctx - Aggregation context
     * @param {Object} row - Row data object
     * @returns {boolean} - True if row was included in aggregation
     */
    processRow: function(ctx, row) {
        ctx.stats.totalRows++;
        
        const config = ctx.config;
        
        // Parse date
        const dateStr = row[config.dateColumn];
        const date = PeriodUtils.parseDate(dateStr, config.dateFormat);
        
        if (!date) {
            ctx.stats.parseErrors++;
            ctx.stats.excludedRows++;
            return false;
        }
        
        // Track date range
        if (!ctx.dateRange.min || date < ctx.dateRange.min) {
            ctx.dateRange.min = new Date(date);
        }
        if (!ctx.dateRange.max || date > ctx.dateRange.max) {
            ctx.dateRange.max = new Date(date);
        }
        
        // Classify period (multi-year or two-period mode)
        let period = null;
        let fiscalYear = null;

        if (ctx.isMultiYear) {
            // Multi-year mode: find which fiscal year this date belongs to
            for (const yearInfo of ctx.yearLookup) {
                if (date >= yearInfo.start && date <= yearInfo.end) {
                    period = String(yearInfo.fy);
                    fiscalYear = yearInfo.fy;
                    break;
                }
            }
        } else {
            // Two-period mode: classify as PY or CY
            period = PeriodUtils.classifyPeriod(date, config.pyRange, config.cyRange);
        }

        if (!period) {
            ctx.stats.outsidePeriodRows++;
            ctx.stats.excludedRows++;
            return false;
        }

        // Parse numeric values
        const sales = CSVParser.parseNumber(row[config.salesColumn]);
        const quantity = CSVParser.parseNumber(row[config.quantityColumn]);
        const cost = config.costColumn ? CSVParser.parseNumber(row[config.costColumn]) : 0;

        // Check for parse errors
        if (isNaN(sales) || isNaN(quantity)) {
            ctx.stats.parseErrors++;
            ctx.stats.excludedRows++;
            return false;
        }

        // Check for negative/zero values (excluded from standard PVM)
        if (sales <= 0 || quantity <= 0) {
            if (ctx.isMultiYear) {
                if (!ctx.negatives[period]) {
                    ctx.negatives[period] = { count: 0, sales: 0, quantity: 0, cost: 0 };
                }
                const negBucket = ctx.negatives[period];
                negBucket.count++;
                negBucket.sales += isNaN(sales) ? 0 : sales;
                negBucket.quantity += isNaN(quantity) ? 0 : quantity;
                negBucket.cost += isNaN(cost) ? 0 : cost;
            } else {
                const negBucket = period === 'PY' ? ctx.negatives.py : ctx.negatives.cy;
                negBucket.count++;
                negBucket.sales += isNaN(sales) ? 0 : sales;
                negBucket.quantity += isNaN(quantity) ? 0 : quantity;
                negBucket.cost += isNaN(cost) ? 0 : cost;
            }

            ctx.stats.excludedRows++;
            return false;
        }

        // Build LOD key
        const lodKey = this._buildLODKey(row, config.dimensions);

        // Get or create aggregation bucket
        if (!ctx.data.has(lodKey)) {
            const newBucket = {
                dimensions: this._extractDimensions(row, config.dimensions)
            };

            if (ctx.isMultiYear) {
                // Multi-year mode: create years object
                newBucket.years = {};
                for (const yearInfo of ctx.yearLookup) {
                    newBucket.years[yearInfo.fy] = { sales: 0, quantity: 0, cost: 0, count: 0 };
                }
            } else {
                // Two-period mode: create py/cy
                newBucket.py = { sales: 0, quantity: 0, cost: 0, count: 0 };
                newBucket.cy = { sales: 0, quantity: 0, cost: 0, count: 0 };
            }

            ctx.data.set(lodKey, newBucket);
            ctx.stats.uniqueLODKeys++;
        }

        const bucket = ctx.data.get(lodKey);

        let periodBucket;
        if (ctx.isMultiYear) {
            periodBucket = bucket.years[fiscalYear];
        } else {
            periodBucket = period === 'PY' ? bucket.py : bucket.cy;
        }

        // Accumulate
        periodBucket.sales += sales;
        periodBucket.quantity += quantity;
        periodBucket.cost += isNaN(cost) ? 0 : cost;
        periodBucket.count++;

        // Update stats
        ctx.stats.includedRows++;
        if (ctx.isMultiYear) {
            if (!ctx.stats.yearRows[fiscalYear]) {
                ctx.stats.yearRows[fiscalYear] = 0;
            }
            ctx.stats.yearRows[fiscalYear]++;
        } else {
            if (period === 'PY') {
                ctx.stats.pyRows++;
            } else {
                ctx.stats.cyRows++;
            }
        }

        return true;
    },

    /**
     * Build LOD key from row and dimension columns
     * 
     * @private
     */
    _buildLODKey: function(row, dimensions) {
        if (!dimensions || dimensions.length === 0) {
            return '__TOTAL__';
        }
        
        return dimensions.map(dim => {
            const value = row[dim];
            return value && value.trim() ? value.trim() : CONFIG.DEFAULTS.UNKNOWN_DIMENSION_VALUE;
        }).join('|||');
    },

    /**
     * Extract dimension values from row
     * 
     * @private
     */
    _extractDimensions: function(row, dimensions) {
        const result = {};
        for (const dim of dimensions) {
            const value = row[dim];
            result[dim] = value && value.trim() ? value.trim() : CONFIG.DEFAULTS.UNKNOWN_DIMENSION_VALUE;
        }
        return result;
    },

    /**
     * Finalize aggregation and return results
     *
     * @param {Object} ctx - Aggregation context
     * @returns {Object} - Final aggregation results
     */
    finalize: function(ctx) {
        // Convert Map to array for easier processing
        const aggregatedData = [];

        for (const [key, bucket] of ctx.data) {
            const dataItem = {
                lodKey: key,
                dimensions: bucket.dimensions
            };

            if (ctx.isMultiYear) {
                // Multi-year mode: copy years object
                dataItem.years = {};
                for (const fy in bucket.years) {
                    dataItem.years[fy] = { ...bucket.years[fy] };
                }
            } else {
                // Two-period mode: copy py/cy
                dataItem.py = { ...bucket.py };
                dataItem.cy = { ...bucket.cy };
            }

            aggregatedData.push(dataItem);
        }

        const result = {
            data: aggregatedData,
            negatives: ctx.negatives,
            stats: ctx.stats,
            dateRange: ctx.dateRange,
            isMultiYear: ctx.isMultiYear,
            config: {
                dimensions: ctx.config.dimensions
            }
        };

        if (ctx.isMultiYear) {
            result.config.fiscalYears = ctx.config.fiscalYears;
            result.config.fyEndMonth = ctx.config.fyEndMonth;
        } else {
            result.config.pyRange = ctx.config.pyRange;
            result.config.cyRange = ctx.config.cyRange;
        }

        return result;
    },

    /**
     * Calculate totals across all LOD combinations
     *
     * @param {Object[]} aggregatedData - Array of aggregated buckets
     * @param {boolean} isMultiYear - Whether this is multi-year data
     * @returns {Object} - Totals { py: {...}, cy: {...} } or { years: {2016: {...}, 2017: {...}} }
     */
    calculateTotals: function(aggregatedData, isMultiYear = false) {
        if (isMultiYear) {
            // Multi-year mode: calculate totals for each year
            const totals = { years: {} };

            // First pass: discover all years
            for (const bucket of aggregatedData) {
                for (const fy in bucket.years) {
                    if (!totals.years[fy]) {
                        totals.years[fy] = { sales: 0, quantity: 0, cost: 0, count: 0 };
                    }
                }
            }

            // Second pass: sum up values
            for (const bucket of aggregatedData) {
                for (const fy in bucket.years) {
                    totals.years[fy].sales += bucket.years[fy].sales;
                    totals.years[fy].quantity += bucket.years[fy].quantity;
                    totals.years[fy].cost += bucket.years[fy].cost;
                    totals.years[fy].count += bucket.years[fy].count;
                }
            }

            return totals;
        } else {
            // Two-period mode: calculate PY/CY totals
            const totals = {
                py: { sales: 0, quantity: 0, cost: 0, count: 0 },
                cy: { sales: 0, quantity: 0, cost: 0, count: 0 }
            };

            for (const bucket of aggregatedData) {
                totals.py.sales += bucket.py.sales;
                totals.py.quantity += bucket.py.quantity;
                totals.py.cost += bucket.py.cost;
                totals.py.count += bucket.py.count;

                totals.cy.sales += bucket.cy.sales;
                totals.cy.quantity += bucket.cy.quantity;
                totals.cy.cost += bucket.cy.cost;
                totals.cy.count += bucket.cy.count;
            }

            return totals;
        }
    }
};

if (typeof module !== 'undefined' && module.exports) {
    module.exports = Aggregator;
}

// ============================================
// bridge-calculator.js
// ============================================
/**
 * ============================================
 * PVM Bridge Tool - Bridge Calculator
 * ============================================
 * 
 * Core PVM and Gross Margin bridge calculations.
 * All formulas are documented for auditability.
 * 
 * PVM Bridge Formulas:
 * - Price Impact = (CY Price - PY Price) √ó PY Volume
 * - Volume Impact = (CY Volume - PY Volume) √ó PY Price
 * - Mix Impact = Total Change - Price Impact - Volume Impact
 * 
 * Special Cases:
 * - New items (PY = 0): All impact goes to Volume
 * - Discontinued (CY = 0): All impact goes to Volume
 * ============================================
 */

const BridgeCalculator = {
    /**
     * Calculate PVM bridge for aggregated data
     *
     * @param {Object[]} aggregatedData - Array of LOD buckets
     * @param {Object} options - Calculation options
     * @param {string} options.mode - 'pvm' or 'gm'
     * @param {string} options.gmPriceDefinition - For GM mode: 'margin-per-unit' or 'sales-per-unit'
     * @param {boolean} options.isMultiYear - Whether this is multi-year data
     * @param {Object[]} options.fiscalYears - Array of fiscal year configs (for multi-year)
     * @returns {Object} - Bridge results
     */
    calculate: function(aggregatedData, options = {}) {
        const mode = options.mode || 'pvm';
        const gmPriceDef = options.gmPriceDefinition || 'margin-per-unit';
        const isMultiYear = options.isMultiYear || false;
        const fiscalYears = options.fiscalYears || [];

        if (isMultiYear && fiscalYears.length > 0) {
            // Multi-year mode: calculate metrics for each year and YoY bridges
            const detailResults = aggregatedData.map(bucket => {
                return this._calculateMultiYearBucket(bucket, mode, gmPriceDef, fiscalYears);
            });

            const summary = this._calculateMultiYearSummary(detailResults, mode, fiscalYears);

            return {
                detail: detailResults,
                summary: summary,
                mode: mode,
                gmPriceDefinition: gmPriceDef,
                isMultiYear: true,
                fiscalYears: fiscalYears
            };
        } else {
            // Two-period mode: existing logic
            const detailResults = aggregatedData.map(bucket => {
                return this._calculateBucket(bucket, mode, gmPriceDef);
            });

            const summary = this._calculateSummary(detailResults, mode);

            return {
                detail: detailResults,
                summary: summary,
                mode: mode,
                gmPriceDefinition: gmPriceDef,
                isMultiYear: false
            };
        }
    },

    /**
     * Calculate bridge for a single LOD bucket
     * 
     * @private
     */
    _calculateBucket: function(bucket, mode, gmPriceDef) {
        const py = bucket.py;
        const cy = bucket.cy;
        
        // Determine if this is new, discontinued, or continuing
        const isNew = py.sales <= 0 || py.quantity <= 0;
        const isDiscontinued = cy.sales <= 0 || cy.quantity <= 0;
        
        // Get the "value" based on mode
        let pyValue, cyValue;
        
        if (mode === 'gm') {
            if (gmPriceDef === 'margin-per-unit') {
                // Value = Gross Margin = Sales - Cost
                pyValue = py.sales - py.cost;
                cyValue = cy.sales - cy.cost;
            } else {
                // Value = Sales (cost handled separately)
                pyValue = py.sales;
                cyValue = cy.sales;
            }
        } else {
            // PVM mode: Value = Sales (Revenue)
            pyValue = py.sales;
            cyValue = cy.sales;
        }
        
        // Calculate prices (value per unit)
        const pyPrice = py.quantity > 0 ? pyValue / py.quantity : 0;
        const cyPrice = cy.quantity > 0 ? cyValue / cy.quantity : 0;
        
        // Volumes
        const pyVolume = py.quantity;
        const cyVolume = cy.quantity;
        
        // Total change
        const totalChange = cyValue - pyValue;
        
        // Initialize impacts
        let priceImpact = 0;
        let volumeImpact = 0;
        let mixImpact = 0;
        let costImpact = 0; // Only used in GM mode with sales-per-unit
        
        // Classification for audit trail
        let classification = 'continuing';
        
        if (isNew) {
            // New item: all impact goes to volume
            classification = 'new';
            priceImpact = 0;
            volumeImpact = totalChange;
            mixImpact = 0;
        } else if (isDiscontinued) {
            // Discontinued: all impact goes to volume
            classification = 'discontinued';
            priceImpact = 0;
            volumeImpact = totalChange;
            mixImpact = 0;
        } else {
            // Continuing item: calculate all three components
            classification = 'continuing';
            
            // Price Impact = (CY Price - PY Price) √ó PY Volume
            priceImpact = (cyPrice - pyPrice) * pyVolume;
            
            // Volume Impact = (CY Volume - PY Volume) √ó PY Price
            volumeImpact = (cyVolume - pyVolume) * pyPrice;
            
            // Mix Impact = Residual (ensures exact reconciliation)
            mixImpact = totalChange - priceImpact - volumeImpact;
        }
        
        // For GM mode with sales-per-unit, calculate cost impact
        if (mode === 'gm' && gmPriceDef === 'sales-per-unit') {
            costImpact = -(cy.cost - py.cost);
        }
        
        return {
            lodKey: bucket.lodKey,
            dimensions: bucket.dimensions,
            
            // Period values
            py: {
                value: pyValue,
                price: pyPrice,
                volume: pyVolume,
                sales: py.sales,
                cost: py.cost,
                count: py.count
            },
            cy: {
                value: cyValue,
                price: cyPrice,
                volume: cyVolume,
                sales: cy.sales,
                cost: cy.cost,
                count: cy.count
            },
            
            // Bridge components
            totalChange: totalChange,
            priceImpact: priceImpact,
            volumeImpact: volumeImpact,
            mixImpact: mixImpact,
            costImpact: costImpact,
            
            // Classification
            classification: classification,
            isNew: isNew,
            isDiscontinued: isDiscontinued
        };
    },

    /**
     * Calculate summary totals from detail results
     * 
     * @private
     */
    _calculateSummary: function(detailResults, mode) {
        const summary = {
            py: { value: 0, sales: 0, quantity: 0, cost: 0, count: 0 },
            cy: { value: 0, sales: 0, quantity: 0, cost: 0, count: 0 },
            
            totalChange: 0,
            priceImpact: 0,
            volumeImpact: 0,
            mixImpact: 0,
            costImpact: 0,
            
            counts: {
                total: detailResults.length,
                new: 0,
                discontinued: 0,
                continuing: 0
            }
        };
        
        for (const result of detailResults) {
            // Sum period values
            summary.py.value += result.py.value;
            summary.py.sales += result.py.sales;
            summary.py.quantity += result.py.volume;
            summary.py.cost += result.py.cost;
            summary.py.count += result.py.count;
            
            summary.cy.value += result.cy.value;
            summary.cy.sales += result.cy.sales;
            summary.cy.quantity += result.cy.volume;
            summary.cy.cost += result.cy.cost;
            summary.cy.count += result.cy.count;
            
            // Sum bridge components
            summary.totalChange += result.totalChange;
            summary.priceImpact += result.priceImpact;
            summary.volumeImpact += result.volumeImpact;
            summary.mixImpact += result.mixImpact;
            summary.costImpact += result.costImpact;
            
            // Count classifications
            summary.counts[result.classification]++;
        }
        
        // Calculate percentages
        const totalChange = summary.totalChange;
        summary.priceImpactPct = totalChange !== 0 ? (summary.priceImpact / Math.abs(totalChange)) * 100 : 0;
        summary.volumeImpactPct = totalChange !== 0 ? (summary.volumeImpact / Math.abs(totalChange)) * 100 : 0;
        summary.mixImpactPct = totalChange !== 0 ? (summary.mixImpact / Math.abs(totalChange)) * 100 : 0;
        summary.costImpactPct = totalChange !== 0 ? (summary.costImpact / Math.abs(totalChange)) * 100 : 0;
        
        // Calculate overall change percentage
        summary.changePct = summary.py.value !== 0 ? ((summary.cy.value - summary.py.value) / Math.abs(summary.py.value)) * 100 : 0;
        
        return summary;
    },

    /**
     * Calculate multi-year metrics and YoY bridges for a single LOD bucket
     *
     * @private
     * @param {Object} bucket - LOD bucket with years data
     * @param {string} mode - 'pvm' or 'gm'
     * @param {string} gmPriceDef - GM price definition
     * @param {Object[]} fiscalYears - Array of fiscal year configs
     * @returns {Object} - Multi-year result with years and bridges
     */
    _calculateMultiYearBucket: function(bucket, mode, gmPriceDef, fiscalYears) {
        const result = {
            lodKey: bucket.lodKey,
            dimensions: bucket.dimensions,
            years: {},
            bridges: {}
        };

        // Calculate metrics for each year
        for (const fyConfig of fiscalYears) {
            const fy = fyConfig.fiscalYear;
            const yearData = bucket.years[fy];

            if (!yearData) continue;

            let value;
            if (mode === 'gm' && gmPriceDef === 'margin-per-unit') {
                value = yearData.sales - yearData.cost;
            } else {
                value = yearData.sales;
            }

            const price = yearData.quantity > 0 ? value / yearData.quantity : 0;

            result.years[fy] = {
                sales: yearData.sales,
                volume: yearData.quantity,
                price: price,
                cost: yearData.cost,
                count: yearData.count,
                value: value
            };
        }

        // Calculate year-over-year bridges between consecutive years
        for (let i = 0; i < fiscalYears.length - 1; i++) {
            const prevFY = fiscalYears[i].fiscalYear;
            const nextFY = fiscalYears[i + 1].fiscalYear;
            const bridgeKey = `${prevFY}-${nextFY}`;

            const py = result.years[prevFY];
            const cy = result.years[nextFY];

            if (!py || !cy) continue;

            // Determine if this is new, discontinued, or continuing
            const isNew = py.sales <= 0 || py.volume <= 0;
            const isDiscontinued = cy.sales <= 0 || cy.volume <= 0;

            const totalChange = cy.value - py.value;

            let priceImpact = 0;
            let volumeImpact = 0;
            let mixImpact = 0;
            let costImpact = 0;

            if (isNew) {
                // New item: all impact goes to volume
                volumeImpact = totalChange;
            } else if (isDiscontinued) {
                // Discontinued: all impact goes to volume
                volumeImpact = totalChange;
            } else {
                // Continuing item: calculate all components
                // Price Impact = (CY Price - PY Price) √ó PY Volume
                priceImpact = (cy.price - py.price) * py.volume;

                // Volume Impact = (CY Volume - PY Volume) √ó PY Price
                volumeImpact = (cy.volume - py.volume) * py.price;

                // Mix Impact = Residual
                mixImpact = totalChange - priceImpact - volumeImpact;
            }

            // Cost impact for GM mode
            if (mode === 'gm' && gmPriceDef === 'sales-per-unit') {
                costImpact = -(cy.cost - py.cost);
            }

            result.bridges[bridgeKey] = {
                totalChange,
                priceImpact,
                volumeImpact,
                mixImpact,
                costImpact,
                isNew,
                isDiscontinued
            };
        }

        return result;
    },

    /**
     * Calculate multi-year summary totals
     *
     * @private
     * @param {Object[]} detailResults - Array of multi-year detail results
     * @param {string} mode - 'pvm' or 'gm'
     * @param {Object[]} fiscalYears - Array of fiscal year configs
     * @returns {Object} - Multi-year summary
     */
    _calculateMultiYearSummary: function(detailResults, mode, fiscalYears) {
        const summary = {
            years: {},
            bridges: {},
            counts: {
                total: detailResults.length
            }
        };

        // Initialize year totals
        for (const fyConfig of fiscalYears) {
            const fy = fyConfig.fiscalYear;
            summary.years[fy] = {
                value: 0,
                sales: 0,
                quantity: 0,
                cost: 0,
                count: 0
            };
        }

        // Initialize bridge totals
        for (let i = 0; i < fiscalYears.length - 1; i++) {
            const prevFY = fiscalYears[i].fiscalYear;
            const nextFY = fiscalYears[i + 1].fiscalYear;
            const bridgeKey = `${prevFY}-${nextFY}`;

            summary.bridges[bridgeKey] = {
                totalChange: 0,
                priceImpact: 0,
                volumeImpact: 0,
                mixImpact: 0,
                costImpact: 0,
                priceImpactPct: 0,
                volumeImpactPct: 0,
                mixImpactPct: 0,
                costImpactPct: 0,
                changePct: 0
            };
        }

        // Sum up values from detail results
        for (const result of detailResults) {
            // Sum year values
            for (const fy in result.years) {
                const yearData = result.years[fy];
                if (summary.years[fy]) {
                    summary.years[fy].value += yearData.value;
                    summary.years[fy].sales += yearData.sales;
                    summary.years[fy].quantity += yearData.volume;
                    summary.years[fy].cost += yearData.cost;
                    summary.years[fy].count += yearData.count;
                }
            }

            // Sum bridge values
            for (const bridgeKey in result.bridges) {
                const bridge = result.bridges[bridgeKey];
                if (summary.bridges[bridgeKey]) {
                    summary.bridges[bridgeKey].totalChange += bridge.totalChange;
                    summary.bridges[bridgeKey].priceImpact += bridge.priceImpact;
                    summary.bridges[bridgeKey].volumeImpact += bridge.volumeImpact;
                    summary.bridges[bridgeKey].mixImpact += bridge.mixImpact;
                    summary.bridges[bridgeKey].costImpact += bridge.costImpact;
                }
            }
        }

        // Calculate percentages for each bridge
        for (const bridgeKey in summary.bridges) {
            const bridge = summary.bridges[bridgeKey];
            const totalChange = bridge.totalChange;

            bridge.priceImpactPct = totalChange !== 0 ? (bridge.priceImpact / Math.abs(totalChange)) * 100 : 0;
            bridge.volumeImpactPct = totalChange !== 0 ? (bridge.volumeImpact / Math.abs(totalChange)) * 100 : 0;
            bridge.mixImpactPct = totalChange !== 0 ? (bridge.mixImpact / Math.abs(totalChange)) * 100 : 0;
            bridge.costImpactPct = totalChange !== 0 ? (bridge.costImpact / Math.abs(totalChange)) * 100 : 0;

            // Calculate overall change percentage
            const [prevFY] = bridgeKey.split('-').map(Number);
            const prevYearValue = summary.years[prevFY] ? summary.years[prevFY].value : 0;
            bridge.changePct = prevYearValue !== 0 ? (totalChange / Math.abs(prevYearValue)) * 100 : 0;
        }

        return summary;
    },

    /**
     * Sort detail results by specified criteria
     * 
     * @param {Object[]} detailResults - Array of detail results
     * @param {string} sortBy - Sort criteria
     * @returns {Object[]} - Sorted results
     */
    sortResults: function(detailResults, sortBy) {
        const sorted = [...detailResults];
        
        switch (sortBy) {
            case 'total-desc':
                sorted.sort((a, b) => Math.abs(b.totalChange) - Math.abs(a.totalChange));
                break;
            case 'total-asc':
                sorted.sort((a, b) => Math.abs(a.totalChange) - Math.abs(b.totalChange));
                break;
            case 'price-desc':
                sorted.sort((a, b) => Math.abs(b.priceImpact) - Math.abs(a.priceImpact));
                break;
            case 'volume-desc':
                sorted.sort((a, b) => Math.abs(b.volumeImpact) - Math.abs(a.volumeImpact));
                break;
            case 'mix-desc':
                sorted.sort((a, b) => Math.abs(b.mixImpact) - Math.abs(a.mixImpact));
                break;
            default:
                // No sorting
                break;
        }
        
        return sorted;
    },

    /**
     * Filter detail results by search term
     * 
     * @param {Object[]} detailResults - Array of detail results
     * @param {string} searchTerm - Search term
     * @returns {Object[]} - Filtered results
     */
    filterResults: function(detailResults, searchTerm) {
        if (!searchTerm || searchTerm.trim() === '') {
            return detailResults;
        }
        
        const term = searchTerm.toLowerCase().trim();
        
        return detailResults.filter(result => {
            // Search in dimension values
            for (const value of Object.values(result.dimensions)) {
                if (String(value).toLowerCase().includes(term)) {
                    return true;
                }
            }
            return false;
        });
    },

    /**
     * Get methodology description for assumptions tab
     */
    getMethodologyDescription: function(mode, gmPriceDef) {
        if (mode === 'gm') {
            if (gmPriceDef === 'margin-per-unit') {
                return {
                    title: 'Gross Margin Bridge (Margin per Unit)',
                    description: 'Analyzes drivers of gross margin change using margin per unit as the price metric.',
                    formulas: [
                        { name: 'Margin per Unit (Price)', formula: '(Sales ‚àí Cost) / Quantity' },
                        { name: 'Price Impact', formula: '(CY Margin/Unit ‚àí PY Margin/Unit) √ó PY Volume' },
                        { name: 'Volume Impact', formula: '(CY Volume ‚àí PY Volume) √ó PY Margin/Unit' },
                        { name: 'Mix Impact', formula: 'Total Change ‚àí Price Impact ‚àí Volume Impact' }
                    ],
                    notes: [
                        'New items (no PY data): Entire change attributed to Volume',
                        'Discontinued items (no CY data): Entire change attributed to Volume',
                        'Mix Impact captures the interaction effect and ensures exact reconciliation'
                    ]
                };
            } else {
                return {
                    title: 'Gross Margin Bridge (Sales per Unit)',
                    description: 'Analyzes drivers of gross margin change with cost impact shown separately.',
                    formulas: [
                        { name: 'Sales per Unit (Price)', formula: 'Sales / Quantity' },
                        { name: 'Price Impact', formula: '(CY Price ‚àí PY Price) √ó PY Volume' },
                        { name: 'Volume Impact', formula: '(CY Volume ‚àí PY Volume) √ó PY Price' },
                        { name: 'Mix Impact', formula: 'Sales Change ‚àí Price Impact ‚àí Volume Impact' },
                        { name: 'Cost Impact', formula: '‚àí(CY Cost ‚àí PY Cost)' }
                    ],
                    notes: [
                        'New items (no PY data): Entire change attributed to Volume',
                        'Discontinued items (no CY data): Entire change attributed to Volume',
                        'Cost Impact is shown separately from the PVM decomposition'
                    ]
                };
            }
        } else {
            return {
                title: 'Sales PVM Bridge',
                description: 'Decomposes revenue change into Price, Volume, and Mix components.',
                formulas: [
                    { name: 'Average Price', formula: 'Sales / Quantity' },
                    { name: 'Price Impact', formula: '(CY Price ‚àí PY Price) √ó PY Volume' },
                    { name: 'Volume Impact', formula: '(CY Volume ‚àí PY Volume) √ó PY Price' },
                    { name: 'Mix Impact', formula: 'Total Change ‚àí Price Impact ‚àí Volume Impact' }
                ],
                notes: [
                    'New items (no PY data): Entire change attributed to Volume',
                    'Discontinued items (no CY data): Entire change attributed to Volume',
                    'Mix Impact captures both product mix shifts and the interaction between price and volume changes',
                    'The three components sum exactly to the total revenue change'
                ]
            };
        }
    }
};

if (typeof module !== 'undefined' && module.exports) {
    module.exports = BridgeCalculator;
}

// ============================================
// ui-renderer.js
// ============================================
/**
 * ============================================
 * PVM Bridge Tool - UI Renderer
 * ============================================
 * 
 * Pure DOM manipulation for rendering results.
 * No innerHTML for user data (security).
 * Accessible markup with ARIA labels.
 * ============================================
 */

const UIRenderer = {
    /**
     * Format a number for display
     * 
     * @param {number} value - Number to format
     * @param {string} type - 'currency', 'quantity', 'price', 'percent'
     * @returns {string} - Formatted string
     */
    formatNumber: function(value, type = 'currency') {
        if (value === null || value === undefined || isNaN(value)) {
            return '--';
        }
        
        let decimals;
        let prefix = '';
        let suffix = '';
        
        switch (type) {
            case 'currency':
                decimals = CONFIG.FORMAT.DECIMALS_CURRENCY;
                prefix = '$';
                break;
            case 'quantity':
                decimals = CONFIG.FORMAT.DECIMALS_QUANTITY;
                break;
            case 'price':
                decimals = CONFIG.FORMAT.DECIMALS_PRICE;
                prefix = '$';
                break;
            case 'percent':
                decimals = CONFIG.FORMAT.DECIMALS_PERCENT;
                suffix = '%';
                break;
            default:
                decimals = 2;
        }
        
        const absValue = Math.abs(value);
        const formatted = absValue.toLocaleString('en-US', {
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals
        });
        
        const sign = value < 0 ? '-' : '';
        return sign + prefix + formatted + suffix;
    },

    /**
     * Create a text node (safe from XSS)
     */
    text: function(content) {
        return document.createTextNode(content);
    },

    /**
     * Create an element with attributes
     */
    createElement: function(tag, attrs = {}, children = []) {
        const el = document.createElement(tag);

        for (const [key, value] of Object.entries(attrs)) {
            // Skip null/undefined values
            if (value === null || value === undefined) continue;

            if (key === 'className') {
                el.className = value;
            } else if (key === 'textContent') {
                el.textContent = value;
            } else if (key.startsWith('data')) {
                el.setAttribute(key.replace(/([A-Z])/g, '-$1').toLowerCase(), value);
            } else {
                el.setAttribute(key, value);
            }
        }
        
        for (const child of children) {
            if (typeof child === 'string') {
                el.appendChild(this.text(child));
            } else if (child) {
                el.appendChild(child);
            }
        }
        
        return el;
    },

    /**
     * Clear all children from an element
     */
    clearElement: function(element) {
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
    },

    /**
     * Render summary cards
     */
    renderSummaryCards: function(summary, pyPeriodLabel, cyPeriodLabel) {
        const pyValueEl = document.getElementById('summary-py-value');
        const cyValueEl = document.getElementById('summary-cy-value');
        const changeValueEl = document.getElementById('summary-change-value');
        const pyPeriodEl = document.getElementById('summary-py-period');
        const cyPeriodEl = document.getElementById('summary-cy-period');
        const changePctEl = document.getElementById('summary-change-pct');

        // Multi-year mode vs two-period mode
        if (summary.years) {
            // Multi-year: show first and last year
            const years = Object.keys(summary.years).sort((a, b) => Number(a) - Number(b));
            const firstYear = years[0];
            const lastYear = years[years.length - 1];

            pyValueEl.textContent = this.formatNumber(summary.years[firstYear].value, 'currency');
            cyValueEl.textContent = this.formatNumber(summary.years[lastYear].value, 'currency');

            // Calculate total change from first to last year
            const totalChange = summary.years[lastYear].value - summary.years[firstYear].value;
            changeValueEl.textContent = this.formatNumber(totalChange, 'currency');

            pyPeriodEl.textContent = `FY ${firstYear}`;
            cyPeriodEl.textContent = `FY ${lastYear}`;

            const changePct = summary.years[firstYear].value !== 0 ?
                (totalChange / Math.abs(summary.years[firstYear].value)) * 100 : 0;
            const changePctFormatted = this.formatNumber(changePct, 'percent');
            changePctEl.textContent = changePct >= 0 ? '+' + changePctFormatted : changePctFormatted;
            changePctEl.className = 'card-pct ' + (changePct >= 0 ? 'positive' : 'negative');
        } else {
            // Two-period mode: original behavior
            pyValueEl.textContent = this.formatNumber(summary.py.value, 'currency');
            cyValueEl.textContent = this.formatNumber(summary.cy.value, 'currency');
            changeValueEl.textContent = this.formatNumber(summary.totalChange, 'currency');

            pyPeriodEl.textContent = pyPeriodLabel;
            cyPeriodEl.textContent = cyPeriodLabel;

            const changePct = this.formatNumber(summary.changePct, 'percent');
            changePctEl.textContent = summary.changePct >= 0 ? '+' + changePct : changePct;
            changePctEl.className = 'card-pct ' + (summary.changePct >= 0 ? 'positive' : 'negative');
        }
    },

    /**
     * Render bridge summary table
     */
    renderBridgeSummary: function(summary, mode, negatives) {
        const tbody = document.getElementById('bridge-summary-body');
        this.clearElement(tbody);

        let rows = [];

        if (summary.years) {
            // Multi-year mode: show all YoY bridges with year totals
            const years = Object.keys(summary.years).sort((a, b) => Number(a) - Number(b));
            const firstYear = years[0];
            const lastYear = years[years.length - 1];

            // Add year-by-year breakdown
            for (let i = 0; i < years.length; i++) {
                const year = years[i];
                const yearData = summary.years[year];

                // Starting year total
                rows.push({
                    label: `FY ${year}`,
                    value: yearData.value,
                    pct: null,
                    isTotal: true,
                    isStarting: i === 0
                });

                // If not the last year, show bridge to next year
                if (i < years.length - 1) {
                    const nextYear = years[i + 1];
                    const bridgeKey = `${year}-${nextYear}`;
                    const bridge = summary.bridges[bridgeKey];

                    if (bridge) {
                        // Calculate percentages based on starting year value
                        const startValue = yearData.value;
                        const pricePct = startValue !== 0 ? (bridge.priceImpact / Math.abs(startValue)) * 100 : 0;
                        const volPct = startValue !== 0 ? (bridge.volumeImpact / Math.abs(startValue)) * 100 : 0;
                        const mixPct = startValue !== 0 ? (bridge.mixImpact / Math.abs(startValue)) * 100 : 0;

                        rows.push({
                            label: `${year}‚Üí${nextYear} Price Impact`,
                            value: bridge.priceImpact,
                            pct: pricePct,
                            isTotal: false
                        });
                        rows.push({
                            label: `${year}‚Üí${nextYear} Volume Impact`,
                            value: bridge.volumeImpact,
                            pct: volPct,
                            isTotal: false
                        });
                        rows.push({
                            label: `${year}‚Üí${nextYear} Mix Impact`,
                            value: bridge.mixImpact,
                            pct: mixPct,
                            isTotal: false
                        });

                        if (mode === 'gm' && bridge.costImpact !== 0) {
                            const costPct = startValue !== 0 ? (bridge.costImpact / Math.abs(startValue)) * 100 : 0;
                            rows.push({
                                label: `${year}‚Üí${nextYear} Cost Impact`,
                                value: bridge.costImpact,
                                pct: costPct,
                                isTotal: false
                            });
                        }
                    }
                }
            }

            // Add negative values if present (multi-year)
            if (negatives && typeof negatives === 'object' && !negatives.py && !negatives.cy) {
                let negTotal = 0;
                for (const year of years) {
                    if (negatives[year]) {
                        negTotal += negatives[year].sales;
                    }
                }
                if (negTotal !== 0) {
                    rows.push({
                        label: 'Negative Values (excluded)',
                        value: negTotal,
                        pct: null,
                        isTotal: false,
                        isNegatives: true
                    });
                }
            }

        } else {
            // Two-period mode: original behavior
            rows = [
                {
                    label: 'Prior Year',
                    value: summary.py.value,
                    pct: null,
                    isTotal: false,
                    isStarting: true
                },
                {
                    label: 'Price Impact',
                    value: summary.priceImpact,
                    pct: summary.priceImpactPct,
                    isTotal: false
                },
                {
                    label: 'Volume Impact',
                    value: summary.volumeImpact,
                    pct: summary.volumeImpactPct,
                    isTotal: false
                },
                {
                    label: 'Mix Impact',
                    value: summary.mixImpact,
                    pct: summary.mixImpactPct,
                    isTotal: false
                }
            ];

            // Add cost impact for GM mode with sales-per-unit
            if (mode === 'gm' && summary.costImpact !== 0) {
                rows.push({
                    label: 'Cost Impact',
                    value: summary.costImpact,
                    pct: summary.costImpactPct,
                    isTotal: false
                });
            }

            // Add negative values if present
            if (negatives.py && negatives.cy) {
                const negTotal = (negatives.cy.sales - negatives.py.sales);
                if (negTotal !== 0) {
                    rows.push({
                        label: 'Negative Values (excluded)',
                        value: negTotal,
                        pct: null,
                        isTotal: false,
                        isNegatives: true
                    });
                }
            }

            // Add total row
            rows.push({
                label: 'Current Year / LTM',
                value: summary.cy.value,
                pct: null,
                isTotal: true
            });
        }
        
        for (const row of rows) {
            const tr = this.createElement('tr', {
                className: row.isTotal ? 'total-row' : ''
            });
            
            // Label cell
            const labelTd = this.createElement('td', {}, [row.label]);
            tr.appendChild(labelTd);
            
            // Value cell
            const valueTd = this.createElement('td', {
                className: 'num ' + (row.isStarting || row.isTotal ? '' : (row.value >= 0 ? 'positive' : 'negative'))
            });
            valueTd.textContent = this.formatNumber(row.value, 'currency');
            tr.appendChild(valueTd);
            
            // Percent cell
            const pctTd = this.createElement('td', { className: 'num' });
            if (row.pct !== null && row.pct !== undefined) {
                pctTd.textContent = this.formatNumber(row.pct, 'percent');
            } else {
                pctTd.textContent = '--';
            }
            tr.appendChild(pctTd);
            
            tbody.appendChild(tr);
        }
    },

    /**
     * Render bridge waterfall chart
     */
    renderBridgeChart: function(summary, mode) {
        const canvas = document.getElementById('bridge-chart');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');

        // Destroy existing chart if it exists
        if (window.bridgeChartInstance) {
            window.bridgeChartInstance.destroy();
        }

        let labels = [];
        let data = [];
        let colors = [];
        let impactValues = []; // Store actual impact values for labels
        let runningTotal = 0;

        if (summary.years) {
            // Multi-year mode
            const years = Object.keys(summary.years).sort((a, b) => Number(a) - Number(b));

            for (let i = 0; i < years.length; i++) {
                const year = years[i];
                const yearData = summary.years[year];

                // Add year total
                labels.push(`FY ${year}`);
                data.push([0, yearData.value]);
                colors.push('#003B5C'); // Dark blue for totals
                impactValues.push(yearData.value);
                runningTotal = yearData.value;

                // If not the last year, show bridge to next year
                if (i < years.length - 1) {
                    const nextYear = years[i + 1];
                    const bridgeKey = `${year}-${nextYear}`;
                    const bridge = summary.bridges[bridgeKey];

                    if (bridge) {
                        // Price Impact
                        labels.push(`${year}‚Üí${nextYear}\nPrice`);
                        const priceStart = runningTotal;
                        runningTotal += bridge.priceImpact;
                        data.push([priceStart, runningTotal]);
                        colors.push(bridge.priceImpact >= 0 ? '#10B981' : '#EF4444');
                        impactValues.push(bridge.priceImpact);

                        // Volume Impact
                        labels.push(`${year}‚Üí${nextYear}\nVolume`);
                        const volStart = runningTotal;
                        runningTotal += bridge.volumeImpact;
                        data.push([volStart, runningTotal]);
                        colors.push(bridge.volumeImpact >= 0 ? '#10B981' : '#EF4444');
                        impactValues.push(bridge.volumeImpact);

                        // Mix Impact
                        labels.push(`${year}‚Üí${nextYear}\nMix`);
                        const mixStart = runningTotal;
                        runningTotal += bridge.mixImpact;
                        data.push([mixStart, runningTotal]);
                        colors.push(bridge.mixImpact >= 0 ? '#10B981' : '#EF4444');
                        impactValues.push(bridge.mixImpact);

                        // Cost Impact (if GM mode)
                        if (mode === 'gm' && bridge.costImpact !== 0) {
                            labels.push(`${year}‚Üí${nextYear}\nCost`);
                            const costStart = runningTotal;
                            runningTotal += bridge.costImpact;
                            data.push([costStart, runningTotal]);
                            colors.push(bridge.costImpact >= 0 ? '#10B981' : '#EF4444');
                            impactValues.push(bridge.costImpact);
                        }
                    }
                }
            }
        } else {
            // Two-period mode
            labels = ['Prior Year'];
            data = [[0, summary.py.value]];
            colors = ['#003B5C'];
            impactValues = [summary.py.value];
            runningTotal = summary.py.value;

            // Price Impact
            labels.push('Price\nImpact');
            const priceStart = runningTotal;
            runningTotal += summary.priceImpact;
            data.push([priceStart, runningTotal]);
            colors.push(summary.priceImpact >= 0 ? '#10B981' : '#EF4444');
            impactValues.push(summary.priceImpact);

            // Volume Impact
            labels.push('Volume\nImpact');
            const volStart = runningTotal;
            runningTotal += summary.volumeImpact;
            data.push([volStart, runningTotal]);
            colors.push(summary.volumeImpact >= 0 ? '#10B981' : '#EF4444');
            impactValues.push(summary.volumeImpact);

            // Mix Impact
            labels.push('Mix\nImpact');
            const mixStart = runningTotal;
            runningTotal += summary.mixImpact;
            data.push([mixStart, runningTotal]);
            colors.push(summary.mixImpact >= 0 ? '#10B981' : '#EF4444');
            impactValues.push(summary.mixImpact);

            // Cost Impact (if GM mode)
            if (mode === 'gm' && summary.costImpact !== 0) {
                labels.push('Cost\nImpact');
                const costStart = runningTotal;
                runningTotal += summary.costImpact;
                data.push([costStart, runningTotal]);
                colors.push(summary.costImpact >= 0 ? '#10B981' : '#EF4444');
                impactValues.push(summary.costImpact);
            }

            // Current Year Total
            labels.push('Current Year');
            data.push([0, summary.cy.value]);
            colors.push('#003B5C');
            impactValues.push(summary.cy.value);
        }

        // Helper function to format values in thousands
        const formatInThousands = function(value) {
            const absValue = Math.abs(value);
            const sign = value < 0 ? '-' : '';
            if (absValue >= 1000000) {
                return sign + '$' + (absValue / 1000000).toFixed(1) + 'M';
            } else if (absValue >= 1000) {
                return sign + '$' + (absValue / 1000).toFixed(0) + 'K';
            } else {
                return sign + '$' + absValue.toFixed(0);
            }
        };

        // Create chart
        window.bridgeChartInstance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: colors,
                    borderColor: colors.map(c => c),
                    borderWidth: 1,
                    barThickness: 60
                }]
            },
            options: {
                indexAxis: 'x',
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.parsed.y - context.parsed._custom.barStart;
                                return 'Impact: ' + new Intl.NumberFormat('en-US', {
                                    style: 'currency',
                                    currency: 'USD',
                                    minimumFractionDigits: 0,
                                    maximumFractionDigits: 0
                                }).format(value);
                            },
                            afterLabel: function(context) {
                                return 'Total: ' + new Intl.NumberFormat('en-US', {
                                    style: 'currency',
                                    currency: 'USD',
                                    minimumFractionDigits: 0,
                                    maximumFractionDigits: 0
                                }).format(context.parsed.y);
                            }
                        }
                    },
                    datalabels: {
                        color: '#FFFFFF',
                        font: {
                            weight: 'bold',
                            size: 12
                        },
                        formatter: function(value, context) {
                            // Get the actual impact value for this bar
                            const impactValue = impactValues[context.dataIndex];
                            return formatInThousands(impactValue);
                        },
                        anchor: 'center',
                        align: 'center'
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: 11
                            }
                        }
                    },
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                return new Intl.NumberFormat('en-US', {
                                    style: 'currency',
                                    currency: 'USD',
                                    minimumFractionDigits: 0,
                                    maximumFractionDigits: 0
                                }).format(value);
                            }
                        }
                    }
                }
            },
            plugins: [ChartDataLabels]
        });
    },

    /**
     * Render detail table header
     */
    renderDetailTableHeader: function(dimensions, mode, pyLabel, cyLabel, isMultiYear = false, fiscalYears = []) {
        const thead = document.getElementById('detail-table-head');
        this.clearElement(thead);

        const tr = this.createElement('tr');

        // Dimension columns
        for (const dim of dimensions) {
            tr.appendChild(this.createElement('th', {}, [dim]));
        }

        if (isMultiYear && fiscalYears.length > 0) {
            // Multi-year mode: show all years with bridges between them
            for (let i = 0; i < fiscalYears.length; i++) {
                const fy = fiscalYears[i];
                const fyLabel = fy.label || `FY ${fy.fiscalYear}`;

                // Year metrics
                tr.appendChild(this.createElement('th', { className: 'num' }, [`${fyLabel} Sales`]));
                tr.appendChild(this.createElement('th', { className: 'num' }, [`${fyLabel} Vol`]));
                tr.appendChild(this.createElement('th', { className: 'num' }, [`${fyLabel} Price`]));

                // YoY bridge (except for the last year)
                if (i < fiscalYears.length - 1) {
                    const nextFY = fiscalYears[i + 1];
                    const bridgeLabel = `${fy.fiscalYear}‚Üí${nextFY.fiscalYear}`;

                    tr.appendChild(this.createElement('th', { className: 'num' }, [`${bridgeLabel} Price Œî`]));
                    tr.appendChild(this.createElement('th', { className: 'num' }, [`${bridgeLabel} Vol Œî`]));
                    tr.appendChild(this.createElement('th', { className: 'num' }, [`${bridgeLabel} Mix Œî`]));

                    if (mode === 'gm') {
                        tr.appendChild(this.createElement('th', { className: 'num' }, [`${bridgeLabel} Cost Œî`]));
                    }
                }
            }
        } else {
            // Two-period mode: original layout
            // Classification
            tr.appendChild(this.createElement('th', {}, ['Status']));

            // PY values by metric
            tr.appendChild(this.createElement('th', { className: 'num' }, [`${pyLabel} Sales`]));
            tr.appendChild(this.createElement('th', { className: 'num' }, [`${pyLabel} Volume`]));
            tr.appendChild(this.createElement('th', { className: 'num' }, [`${pyLabel} Avg Price`]));

            // CY values by metric
            tr.appendChild(this.createElement('th', { className: 'num' }, [`${cyLabel} Sales`]));
            tr.appendChild(this.createElement('th', { className: 'num' }, [`${cyLabel} Volume`]));
            tr.appendChild(this.createElement('th', { className: 'num' }, [`${cyLabel} Avg Price`]));

            // Bridge components
            tr.appendChild(this.createElement('th', { className: 'num' }, ['Total Change']));
            tr.appendChild(this.createElement('th', { className: 'num' }, ['Price Impact']));
            tr.appendChild(this.createElement('th', { className: 'num' }, ['Volume Impact']));
            tr.appendChild(this.createElement('th', { className: 'num' }, ['Mix Impact']));

            if (mode === 'gm') {
                tr.appendChild(this.createElement('th', { className: 'num' }, ['Cost Impact']));
            }
        }

        thead.appendChild(tr);
    },

    /**
     * Render detail table body (paginated)
     */
    renderDetailTableBody: function(results, dimensions, mode, page = 1, pageSize = 50, isMultiYear = false, fiscalYears = []) {
        const tbody = document.getElementById('detail-table-body');
        this.clearElement(tbody);

        const start = (page - 1) * pageSize;
        const end = Math.min(start + pageSize, results.length);
        const pageResults = results.slice(start, end);

        for (const result of pageResults) {
            const tr = this.createElement('tr');

            // Dimension values
            for (const dim of dimensions) {
                tr.appendChild(this.createElement('td', {}, [result.dimensions[dim] || '--']));
            }

            if (isMultiYear && fiscalYears.length > 0) {
                // Multi-year mode: show all years and YoY bridges

                for (let i = 0; i < fiscalYears.length; i++) {
                    const fy = fiscalYears[i].fiscalYear;
                    const yearData = result.years[fy] || { sales: 0, volume: 0, price: 0 };

                    // Year metrics: Sales, Volume, Price
                    tr.appendChild(this.createElement('td', { className: 'num' }, [
                        this.formatNumber(yearData.sales, 'currency')
                    ]));
                    tr.appendChild(this.createElement('td', { className: 'num' }, [
                        this.formatNumber(yearData.volume, 'number')
                    ]));
                    tr.appendChild(this.createElement('td', { className: 'num' }, [
                        this.formatNumber(yearData.price, 'currency')
                    ]));

                    // YoY bridge columns (between this year and next)
                    if (i < fiscalYears.length - 1) {
                        const nextFY = fiscalYears[i + 1].fiscalYear;
                        const bridgeKey = `${fy}-${nextFY}`;
                        const bridge = result.bridges[bridgeKey] || {
                            priceImpact: 0,
                            volumeImpact: 0,
                            mixImpact: 0
                        };

                        tr.appendChild(this.createElement('td', {
                            className: 'num ' + (bridge.priceImpact >= 0 ? 'positive' : 'negative')
                        }, [this.formatNumber(bridge.priceImpact, 'currency')]));

                        tr.appendChild(this.createElement('td', {
                            className: 'num ' + (bridge.volumeImpact >= 0 ? 'positive' : 'negative')
                        }, [this.formatNumber(bridge.volumeImpact, 'currency')]));

                        tr.appendChild(this.createElement('td', {
                            className: 'num ' + (bridge.mixImpact >= 0 ? 'positive' : 'negative')
                        }, [this.formatNumber(bridge.mixImpact, 'currency')]));

                        if (mode === 'gm') {
                            tr.appendChild(this.createElement('td', {
                                className: 'num ' + (bridge.costImpact >= 0 ? 'positive' : 'negative')
                            }, [this.formatNumber(bridge.costImpact || 0, 'currency')]));
                        }
                    }
                }

            } else {
                // Two-period mode (original behavior)

                // Classification
                const statusClass = result.classification === 'new' ? 'positive' :
                                   result.classification === 'discontinued' ? 'negative' : '';
                tr.appendChild(this.createElement('td', { className: statusClass }, [
                    result.classification.charAt(0).toUpperCase() + result.classification.slice(1)
                ]));

                // PY values: Sales, Volume, Avg Price
                tr.appendChild(this.createElement('td', { className: 'num' }, [
                    this.formatNumber(result.py.sales, 'currency')
                ]));
                tr.appendChild(this.createElement('td', { className: 'num' }, [
                    this.formatNumber(result.py.volume, 'number')
                ]));
                tr.appendChild(this.createElement('td', { className: 'num' }, [
                    this.formatNumber(result.py.price, 'currency')
                ]));

                // CY values: Sales, Volume, Avg Price
                tr.appendChild(this.createElement('td', { className: 'num' }, [
                    this.formatNumber(result.cy.sales, 'currency')
                ]));
                tr.appendChild(this.createElement('td', { className: 'num' }, [
                    this.formatNumber(result.cy.volume, 'number')
                ]));
                tr.appendChild(this.createElement('td', { className: 'num' }, [
                    this.formatNumber(result.cy.price, 'currency')
                ]));

                // Bridge components
                const totalClass = 'num ' + (result.totalChange >= 0 ? 'positive' : 'negative');
                tr.appendChild(this.createElement('td', { className: totalClass }, [
                    this.formatNumber(result.totalChange, 'currency')
                ]));

                tr.appendChild(this.createElement('td', {
                    className: 'num ' + (result.priceImpact >= 0 ? 'positive' : 'negative')
                }, [this.formatNumber(result.priceImpact, 'currency')]));

                tr.appendChild(this.createElement('td', {
                    className: 'num ' + (result.volumeImpact >= 0 ? 'positive' : 'negative')
                }, [this.formatNumber(result.volumeImpact, 'currency')]));

                tr.appendChild(this.createElement('td', {
                    className: 'num ' + (result.mixImpact >= 0 ? 'positive' : 'negative')
                }, [this.formatNumber(result.mixImpact, 'currency')]));

                if (mode === 'gm') {
                    tr.appendChild(this.createElement('td', {
                        className: 'num ' + (result.costImpact >= 0 ? 'positive' : 'negative')
                    }, [this.formatNumber(result.costImpact, 'currency')]));
                }
            }

            tbody.appendChild(tr);
        }

        // Render pagination
        this.renderPagination(results.length, page, pageSize);
    },

    /**
     * Render pagination controls
     */
    renderPagination: function(totalItems, currentPage, pageSize) {
        const container = document.getElementById('detail-pagination');
        this.clearElement(container);
        
        const totalPages = Math.ceil(totalItems / pageSize);
        
        if (totalPages <= 1) return;
        
        // Previous button
        const prevBtn = this.createElement('button', {
            className: 'btn-secondary',
            disabled: currentPage === 1 ? 'disabled' : null
        }, ['‚Üê Previous']);
        prevBtn.dataset.page = currentPage - 1;
        container.appendChild(prevBtn);
        
        // Page info
        const pageInfo = this.createElement('span', { className: 'page-info' }, [
            `Page ${currentPage} of ${totalPages} (${totalItems} items)`
        ]);
        container.appendChild(pageInfo);
        
        // Next button
        const nextBtn = this.createElement('button', {
            className: 'btn-secondary',
            disabled: currentPage === totalPages ? 'disabled' : null
        }, ['Next ‚Üí']);
        nextBtn.dataset.page = currentPage + 1;
        container.appendChild(nextBtn);
    },

    /**
     * Render negatives table
     */
    renderNegativesTable: function(negatives) {
        const tbody = document.getElementById('negatives-table-body');
        this.clearElement(tbody);

        const summary = document.getElementById('negatives-summary');
        this.clearElement(summary);

        // Check if multi-year mode or two-period mode
        const isMultiYear = !negatives.py && !negatives.cy;

        let totalNegCount = 0;
        let totalNegSales = 0;
        let rows = [];

        if (isMultiYear) {
            // Multi-year mode: negatives are keyed by year
            for (const [year, neg] of Object.entries(negatives)) {
                totalNegCount += neg.count;
                totalNegSales += neg.sales;
                if (neg.count > 0) {
                    rows.push({ period: `FY ${year}`, type: 'Negative/Zero Sales or Qty', ...neg });
                }
            }
        } else {
            // Two-period mode: negatives.py and negatives.cy
            totalNegCount = negatives.py.count + negatives.cy.count;
            totalNegSales = negatives.py.sales + negatives.cy.sales;
            rows = [
                { period: 'Prior Year', type: 'Negative/Zero Sales or Qty', ...negatives.py },
                { period: 'Current Year / LTM', type: 'Negative/Zero Sales or Qty', ...negatives.cy }
            ];
        }

        // Summary cards
        summary.appendChild(this.createElement('div', { className: 'summary-card' }, [
            this.createElement('span', { className: 'card-label' }, ['Total Excluded Rows']),
            this.createElement('span', { className: 'card-value' }, [totalNegCount.toLocaleString()])
        ]));

        summary.appendChild(this.createElement('div', { className: 'summary-card' }, [
            this.createElement('span', { className: 'card-label' }, ['Total Excluded Sales']),
            this.createElement('span', { className: 'card-value' }, [this.formatNumber(totalNegSales, 'currency')])
        ]));

        // Table rows
        for (const row of rows) {
            if (row.count === 0) continue;

            const tr = this.createElement('tr');
            tr.appendChild(this.createElement('td', {}, [row.period]));
            tr.appendChild(this.createElement('td', {}, [row.type]));
            tr.appendChild(this.createElement('td', { className: 'num' }, [row.count.toLocaleString()]));
            tr.appendChild(this.createElement('td', { className: 'num' }, [this.formatNumber(row.sales, 'currency')]));
            tr.appendChild(this.createElement('td', { className: 'num' }, [this.formatNumber(row.quantity, 'quantity')]));
            tbody.appendChild(tr);
        }

        if (tbody.children.length === 0) {
            const tr = this.createElement('tr');
            tr.appendChild(this.createElement('td', { colspan: '5', className: 'text-muted' }, [
                'No negative or zero values found'
            ]));
            tbody.appendChild(tr);
        }
    },

    /**
     * Render assumptions tab
     */
    renderAssumptions: function(config, stats, methodology) {
        const configBody = document.getElementById('assumptions-config');
        this.clearElement(configBody);

        const configRows = [
            ['Analysis Mode', config.mode === 'gm' ? 'Gross Margin Bridge' : 'Sales PVM Bridge'],
            ['Fiscal Year End', CONFIG.MONTH_NAMES[config.fyEndMonth - 1]]
        ];

        // Add period information based on mode
        if (config.fiscalYears && config.fiscalYears.length > 0) {
            // Multi-year mode
            const yearLabels = config.fiscalYears.map(fy => fy.label || `FY ${fy.fiscalYear}`).join(', ');
            const firstYear = config.fiscalYears[0];
            const lastYear = config.fiscalYears[config.fiscalYears.length - 1];
            configRows.push(['Analysis Type', 'Multi-Year Comparison']);
            configRows.push(['Fiscal Years', yearLabels]);
            configRows.push(['Date Range', `${PeriodUtils.formatDate(firstYear.start)} to ${PeriodUtils.formatDate(lastYear.end)}`]);
        } else if (config.pyRange && config.cyRange) {
            // Two-period mode
            configRows.push(['Prior Year Period', PeriodUtils.formatDateRange(config.pyRange.start, config.pyRange.end)]);
            configRows.push(['LTM Period', PeriodUtils.formatDateRange(config.cyRange.start, config.cyRange.end)]);
        }

        configRows.push(
            ['Level of Detail', config.dimensions.length > 0 ? config.dimensions.join(', ') : 'Total Only'],
            ['Total Rows Processed', stats.totalRows.toLocaleString()],
            ['Rows Included in Analysis', stats.includedRows.toLocaleString()],
            ['Rows Excluded', stats.excludedRows.toLocaleString()],
            ['Unique LOD Combinations', stats.uniqueLODKeys.toLocaleString()]
        );
        
        if (config.mode === 'gm') {
            configRows.splice(1, 0, ['GM Price Definition', 
                config.gmPriceDefinition === 'margin-per-unit' ? 
                    'Margin per Unit: (Sales ‚àí Cost) / Qty' : 
                    'Sales per Unit: Sales / Qty']);
        }
        
        for (const [label, value] of configRows) {
            const tr = this.createElement('tr');
            tr.appendChild(this.createElement('th', {}, [label]));
            tr.appendChild(this.createElement('td', {}, [value]));
            configBody.appendChild(tr);
        }
        
        // Methodology
        const methodologyEl = document.getElementById('methodology-content');
        this.clearElement(methodologyEl);
        
        methodologyEl.appendChild(this.createElement('p', {}, [methodology.description]));
        
        const formulaList = this.createElement('ul');
        for (const f of methodology.formulas) {
            const li = this.createElement('li');
            li.appendChild(this.createElement('strong', {}, [f.name + ': ']));
            li.appendChild(this.createElement('code', {}, [f.formula]));
            formulaList.appendChild(li);
        }
        methodologyEl.appendChild(formulaList);
        
        // Notes
        const dataQualityEl = document.getElementById('data-quality-content');
        this.clearElement(dataQualityEl);
        
        const notesList = this.createElement('ul');
        for (const note of methodology.notes) {
            notesList.appendChild(this.createElement('li', {}, [note]));
        }
        dataQualityEl.appendChild(notesList);
        
        // Add stats notes
        if (stats.parseErrors > 0) {
            dataQualityEl.appendChild(this.createElement('p', { className: 'text-muted' }, [
                `Note: ${stats.parseErrors.toLocaleString()} rows had parse errors and were excluded.`
            ]));
        }
        
        if (stats.outsidePeriodRows > 0) {
            dataQualityEl.appendChild(this.createElement('p', { className: 'text-muted' }, [
                `Note: ${stats.outsidePeriodRows.toLocaleString()} rows were outside both analysis periods.`
            ]));
        }
    },

    /**
     * Show error modal
     */
    showError: function(message) {
        const modal = document.getElementById('error-modal');
        const body = document.getElementById('error-modal-body');
        body.textContent = message;
        modal.classList.remove('hidden');
    },

    /**
     * Hide error modal
     */
    hideError: function() {
        const modal = document.getElementById('error-modal');
        modal.classList.add('hidden');
    }
};

if (typeof module !== 'undefined' && module.exports) {
    module.exports = UIRenderer;
}

// ============================================
// excel-export.js
// ============================================
/**
 * ============================================
 * PVM Bridge Tool - Excel Export
 * ============================================
 * 
 * Generates XLSX files with multiple tabs:
 * 1. Summary Bridge
 * 2. Detail by LOD
 * 3. Negative Values
 * 4. Assumptions & Metadata
 * 
 * Uses SheetJS (xlsx.mini.js) for Excel generation.
 * All data is numeric/text for easy charting.
 * ============================================
 */

const ExcelExport = {
    /**
     * Export results to Excel file
     * 
     * @param {Object} bridgeResults - Results from BridgeCalculator
     * @param {Object} aggregationResults - Results from Aggregator
     * @param {Object} config - Analysis configuration
     */
    exportToExcel: function(bridgeResults, aggregationResults, config) {
        // Create workbook with cell styles enabled
        const wb = XLSX.utils.book_new();
        wb.Workbook = wb.Workbook || {};
        wb.Workbook.Views = wb.Workbook.Views || [{}];
        wb.Workbook.Views[0] = wb.Workbook.Views[0] || {};
        
        // Tab 1: Summary Bridge
        const summarySheet = this._createSummarySheet(bridgeResults.summary, config, aggregationResults.negatives);
        XLSX.utils.book_append_sheet(wb, summarySheet, CONFIG.EXCEL.TAB_NAMES.SUMMARY);
        
        // Tab 2: Detail by LOD
        const detailSheet = this._createDetailSheet(bridgeResults.detail, config);
        XLSX.utils.book_append_sheet(wb, detailSheet, CONFIG.EXCEL.TAB_NAMES.DETAIL);
        
        // Tab 3: Negative Values
        const negativesSheet = this._createNegativesSheet(aggregationResults.negatives, aggregationResults.stats);
        XLSX.utils.book_append_sheet(wb, negativesSheet, CONFIG.EXCEL.TAB_NAMES.NEGATIVES);
        
        // Tab 4: Assumptions
        const assumptionsSheet = this._createAssumptionsSheet(config, aggregationResults.stats, bridgeResults.mode);
        XLSX.utils.book_append_sheet(wb, assumptionsSheet, CONFIG.EXCEL.TAB_NAMES.ASSUMPTIONS);
        
        // Generate filename with timestamp
        const timestamp = new Date().toISOString().slice(0, 10);
        const modeLabel = config.mode === 'gm' ? 'GM_Bridge' : 'PVM_Bridge';
        const filename = `${modeLabel}_${timestamp}.xlsx`;

        // Trigger download
        XLSX.writeFile(wb, filename);
    },

    /**
     * Create Summary Bridge sheet
     * @private
     */
    _createSummarySheet: function(summary, config, negatives) {
        const data = [];

        // Header section
        data.push([config.mode === 'gm' ? 'Gross Margin Bridge Summary' : 'Sales PVM Bridge Summary']);
        data.push([`Generated: ${new Date().toLocaleString()}`]);
        data.push([]);

        if (summary.years) {
            // Multi-year mode
            const years = Object.keys(summary.years).sort((a, b) => Number(a) - Number(b));

            // Period summary
            data.push(['Period Summary']);
            data.push(['Fiscal Year', 'Value', 'Quantity', 'Transactions']);
            for (const year of years) {
                const yearData = summary.years[year];
                data.push([
                    `FY ${year}`,
                    yearData.value,
                    yearData.quantity,
                    yearData.count
                ]);
            }
            data.push([]);

            // Year-over-year bridge analysis
            data.push(['Year-over-Year Bridge Analysis']);
            data.push(['Component', 'Impact ($)', '% of Change']);

            // Add each year with bridge impacts to next year
            for (let i = 0; i < years.length; i++) {
                const year = years[i];
                const yearData = summary.years[year];

                // Year total row
                data.push([`FY ${year}`, yearData.value, '']);

                // If not the last year, show bridge to next year
                if (i < years.length - 1) {
                    const nextYear = years[i + 1];
                    const bridgeKey = `${year}-${nextYear}`;
                    const bridge = summary.bridges[bridgeKey];

                    if (bridge) {
                        // Calculate percentages based on starting year value
                        const startValue = yearData.value;
                        const pricePct = startValue !== 0 ? (bridge.priceImpact / Math.abs(startValue)) * 100 : 0;
                        const volumePct = startValue !== 0 ? (bridge.volumeImpact / Math.abs(startValue)) * 100 : 0;
                        const mixPct = startValue !== 0 ? (bridge.mixImpact / Math.abs(startValue)) * 100 : 0;

                        data.push([`${year}‚Üí${nextYear} Price Impact`, bridge.priceImpact, pricePct / 100]);
                        data.push([`${year}‚Üí${nextYear} Volume Impact`, bridge.volumeImpact, volumePct / 100]);
                        data.push([`${year}‚Üí${nextYear} Mix Impact`, bridge.mixImpact, mixPct / 100]);

                        if (config.mode === 'gm' && bridge.costImpact !== 0) {
                            const costPct = startValue !== 0 ? (bridge.costImpact / Math.abs(startValue)) * 100 : 0;
                            data.push([`${year}‚Üí${nextYear} Cost Impact`, bridge.costImpact, costPct / 100]);
                        }
                    }
                }
            }

            data.push([]);

            // LOD counts
            data.push(['LOD Analysis Summary']);
            data.push(['Category', 'Count']);
            data.push(['Total LOD Combinations', summary.counts.total]);

        } else {
            // Two-period mode: original behavior
            const pyLabel = config.pyLabel || 'Prior Year';
            const cyLabel = config.cyLabel || 'Current Year';

            data.push(['Period Summary']);
            data.push(['Period', 'Start Date', 'End Date', 'Value', 'Quantity', 'Transactions']);
            data.push([
                pyLabel,
                PeriodUtils.formatDate(config.pyRange.start),
                PeriodUtils.formatDate(config.pyRange.end),
                summary.py.value,
                summary.py.quantity,
                summary.py.count
            ]);
            data.push([
                cyLabel,
                PeriodUtils.formatDate(config.cyRange.start),
                PeriodUtils.formatDate(config.cyRange.end),
                summary.cy.value,
                summary.cy.quantity,
                summary.cy.count
            ]);
            data.push([]);

            // Bridge components
            data.push(['Bridge Analysis']);
            data.push(['Component', 'Impact ($)', '% of Total Change']);
            data.push([`${pyLabel} Starting Value`, summary.py.value, '']);
            data.push(['Price Impact', summary.priceImpact, summary.priceImpactPct / 100]);
            data.push(['Volume Impact', summary.volumeImpact, summary.volumeImpactPct / 100]);
            data.push(['Mix Impact', summary.mixImpact, summary.mixImpactPct / 100]);

            if (config.mode === 'gm' && summary.costImpact !== 0) {
                data.push(['Cost Impact', summary.costImpact, summary.costImpactPct / 100]);
            }

            // Negative values row (only for two-period mode)
            if (negatives.py && negatives.cy) {
                const negTotal = negatives.cy.sales - negatives.py.sales;
                if (negTotal !== 0) {
                    data.push(['Negative Values (excluded from above)', negTotal, '']);
                }
            }

            data.push([`${cyLabel} Ending Value`, summary.cy.value, '']);
            data.push([]);

            // Total change summary
            data.push(['Total Change', summary.totalChange, summary.changePct / 100]);
            data.push([]);

            // LOD counts
            data.push(['LOD Analysis Summary']);
            data.push(['Category', 'Count']);
            data.push(['Total LOD Combinations', summary.counts.total]);
            data.push(['New Items (in CY only)', summary.counts.new]);
            data.push(['Discontinued Items (in PY only)', summary.counts.discontinued]);
            data.push(['Continuing Items', summary.counts.continuing]);
        }
        
        const ws = XLSX.utils.aoa_to_sheet(data);

        // Apply number formatting to value columns
        const range = XLSX.utils.decode_range(ws['!ref']);
        for (let R = range.s.r + 1; R <= range.e.r; ++R) {
            for (let C = range.s.c; C <= range.e.c; ++C) {
                const cell_address = XLSX.utils.encode_cell({r: R, c: C});
                if (!ws[cell_address]) continue;

                // Format based on column position
                if (typeof ws[cell_address].v === 'number') {
                    if (C === 1) {
                        // Column 1: Currency format
                        ws[cell_address].z = '$#,##0';
                        ws[cell_address].t = 'n';
                    } else if (C === 2) {
                        // Column 2: Percentage format
                        ws[cell_address].z = '0.0%';
                        ws[cell_address].t = 'n';
                    } else if (C >= 3) {
                        // Other number columns: comma format
                        ws[cell_address].z = '#,##0';
                        ws[cell_address].t = 'n';
                    }
                }
            }
        }

        // Set column widths
        ws['!cols'] = [
            { wch: 30 },
            { wch: 18 },
            { wch: 18 },
            { wch: 18 },
            { wch: 15 },
            { wch: 15 }
        ];

        return ws;
    },

    /**
     * Create Detail sheet
     * @private
     */
    _createDetailSheet: function(detail, config) {
        const data = [];
        const dimensions = config.dimensions || [];

        // Check if multi-year mode
        const isMultiYear = config.fiscalYears && config.fiscalYears.length > 0;
        const fiscalYears = isMultiYear ? config.fiscalYears : [];

        let headerRow;

        if (isMultiYear) {
            // Multi-year mode: header grouped by KPI with blank columns between groups for visual separation
            headerRow = [...dimensions];

            // Group 1: Annual Sales for all years
            headerRow.push(''); // Blank column for separation
            for (let i = 0; i < fiscalYears.length; i++) {
                const fyLabel = fiscalYears[i].label || `FY ${fiscalYears[i].fiscalYear}`;
                headerRow.push(`${fyLabel} Sales`);
            }

            // Group 2: Annual Volume for all years
            headerRow.push(''); // Blank column for separation
            for (let i = 0; i < fiscalYears.length; i++) {
                const fyLabel = fiscalYears[i].label || `FY ${fiscalYears[i].fiscalYear}`;
                headerRow.push(`${fyLabel} Volume`);
            }

            // Group 3: Annual Avg Price for all years
            headerRow.push(''); // Blank column for separation
            for (let i = 0; i < fiscalYears.length; i++) {
                const fyLabel = fiscalYears[i].label || `FY ${fiscalYears[i].fiscalYear}`;
                headerRow.push(`${fyLabel} Avg Price`);
            }

            // Group 4: Price Impacts (YoY)
            headerRow.push(''); // Blank column for separation
            for (let i = 0; i < fiscalYears.length - 1; i++) {
                const fy = fiscalYears[i];
                const nextFY = fiscalYears[i + 1];
                const bridgeLabel = `${fy.fiscalYear}‚Üí${nextFY.fiscalYear}`;
                headerRow.push(`${bridgeLabel} Price Impact`);
            }

            // Group 5: Volume Impacts (YoY)
            headerRow.push(''); // Blank column for separation
            for (let i = 0; i < fiscalYears.length - 1; i++) {
                const fy = fiscalYears[i];
                const nextFY = fiscalYears[i + 1];
                const bridgeLabel = `${fy.fiscalYear}‚Üí${nextFY.fiscalYear}`;
                headerRow.push(`${bridgeLabel} Volume Impact`);
            }

            // Group 6: Mix Impacts (YoY)
            headerRow.push(''); // Blank column for separation
            for (let i = 0; i < fiscalYears.length - 1; i++) {
                const fy = fiscalYears[i];
                const nextFY = fiscalYears[i + 1];
                const bridgeLabel = `${fy.fiscalYear}‚Üí${nextFY.fiscalYear}`;
                headerRow.push(`${bridgeLabel} Mix Impact`);
            }

            // Group 7: Cost Impacts (YoY) - if GM mode
            if (config.mode === 'gm') {
                headerRow.push(''); // Blank column for separation
                for (let i = 0; i < fiscalYears.length - 1; i++) {
                    const fy = fiscalYears[i];
                    const nextFY = fiscalYears[i + 1];
                    const bridgeLabel = `${fy.fiscalYear}‚Üí${nextFY.fiscalYear}`;
                    headerRow.push(`${bridgeLabel} Cost Impact`);
                }
            }
        } else{
            // Two-period mode: original behavior
            const pyLabel = config.pyLabel || 'PY';
            const cyLabel = config.cyLabel || 'CY';

            headerRow = [
                ...dimensions,
                'Status',
                `${pyLabel} Sales`,
                `${pyLabel} Volume`,
                `${pyLabel} Avg Price`,
                `${cyLabel} Sales`,
                `${cyLabel} Volume`,
                `${cyLabel} Avg Price`,
                'Total Change',
                'Price Impact',
                'Volume Impact',
                'Mix Impact'
            ];

            if (config.mode === 'gm') {
                headerRow.push('Cost Impact');
            }
        }

        data.push(headerRow);

        // Data rows
        for (let i = 0; i < detail.length; i++) {
            const row = detail[i];

            if (isMultiYear) {
                // Multi-year mode: populate grouped by KPI with blank columns between groups
                const dataRow = [...dimensions.map(d => row.dimensions[d] || 'Unknown')];

                // Group 1: Annual Sales for all years
                dataRow.push(''); // Blank column for separation
                for (let j = 0; j < fiscalYears.length; j++) {
                    const fy = fiscalYears[j].fiscalYear;
                    const yearData = row.years[fy] || { sales: 0, volume: 0, price: 0 };
                    dataRow.push(yearData.sales);
                }

                // Group 2: Annual Volume for all years
                dataRow.push(''); // Blank column for separation
                for (let j = 0; j < fiscalYears.length; j++) {
                    const fy = fiscalYears[j].fiscalYear;
                    const yearData = row.years[fy] || { sales: 0, volume: 0, price: 0 };
                    dataRow.push(yearData.volume);
                }

                // Group 3: Annual Avg Price for all years (will be replaced with formulas)
                dataRow.push(''); // Blank column for separation
                for (let j = 0; j < fiscalYears.length; j++) {
                    dataRow.push(0); // Placeholder for formula
                }

                // Group 4: Price Impacts (YoY) - placeholders for formulas
                dataRow.push(''); // Blank column for separation
                for (let j = 0; j < fiscalYears.length - 1; j++) {
                    dataRow.push(0);
                }

                // Group 5: Volume Impacts (YoY) - placeholders for formulas
                dataRow.push(''); // Blank column for separation
                for (let j = 0; j < fiscalYears.length - 1; j++) {
                    dataRow.push(0);
                }

                // Group 6: Mix Impacts (YoY) - placeholders for formulas
                dataRow.push(''); // Blank column for separation
                for (let j = 0; j < fiscalYears.length - 1; j++) {
                    dataRow.push(0);
                }

                // Group 7: Cost Impacts (YoY) - placeholders for formulas (if GM mode)
                if (config.mode === 'gm') {
                    dataRow.push(''); // Blank column for separation
                    for (let j = 0; j < fiscalYears.length - 1; j++) {
                        dataRow.push(0);
                    }
                }

                data.push(dataRow);
            } else {
                // Two-period mode: original behavior
                const dataRow = [
                    ...dimensions.map(d => row.dimensions[d] || 'Unknown'),
                    row.classification,
                    row.py.sales,
                    row.py.volume,
                    row.py.price,
                    row.cy.sales,
                    row.cy.volume,
                    row.cy.price
                ];

                data.push(dataRow);
            }
        }

        // Create worksheet from data
        const ws = XLSX.utils.aoa_to_sheet(data);

        // Column letter helper
        const colLetter = (col) => {
            let letter = '';
            let num = col;
            while (num >= 0) {
                letter = String.fromCharCode((num % 26) + 65) + letter;
                num = Math.floor(num / 26) - 1;
            }
            return letter;
        };

        // Now add formulas for bridge calculations
        const dimCount = dimensions.length;

        if (isMultiYear) {
            // Multi-year mode: add formulas for grouped columns
            // Note: Each group has a blank separator column before it
            const numYears = fiscalYears.length;
            const numBridges = numYears - 1;
            const numCostImpactCols = config.mode === 'gm' ? 1 : 0;

            // Calculate column positions for each group (accounting for blank separator columns)
            const salesStartCol = dimCount + 1; // +1 for blank column before sales group
            const volumeStartCol = salesStartCol + numYears + 1; // +1 for blank column before volume group
            const priceStartCol = volumeStartCol + numYears + 1; // +1 for blank column before price group
            const priceImpactStartCol = priceStartCol + numYears + 1; // +1 for blank column before price impact group
            const volumeImpactStartCol = priceImpactStartCol + numBridges + 1; // +1 for blank column
            const mixImpactStartCol = volumeImpactStartCol + numBridges + 1; // +1 for blank column
            const costImpactStartCol = config.mode === 'gm' ? mixImpactStartCol + numBridges + 1 : -1;

            for (let i = 0; i < detail.length; i++) {
                const rowNum = i + 2; // Excel row number (1-indexed, +1 for header)

                // Add Avg Price formulas: Sales / Volume for each year
                for (let j = 0; j < numYears; j++) {
                    const salesCol = salesStartCol + j;
                    const volCol = volumeStartCol + j;
                    const priceCol = priceStartCol + j;

                    ws[`${colLetter(priceCol)}${rowNum}`] = {
                        f: `IF(${colLetter(volCol)}${rowNum}=0,0,${colLetter(salesCol)}${rowNum}/${colLetter(volCol)}${rowNum})`,
                        t: 'n'
                    };
                }

                // Add YoY bridge impact formulas
                for (let j = 0; j < numBridges; j++) {
                    const thisSalesCol = salesStartCol + j;
                    const thisVolCol = volumeStartCol + j;
                    const thisPriceCol = priceStartCol + j;
                    const nextSalesCol = salesStartCol + j + 1;
                    const nextVolCol = volumeStartCol + j + 1;
                    const nextPriceCol = priceStartCol + j + 1;

                    const priceImpactCol = priceImpactStartCol + j;
                    const volumeImpactCol = volumeImpactStartCol + j;
                    const mixImpactCol = mixImpactStartCol + j;

                    // Price Impact = (Next Price - This Price) √ó This Volume
                    ws[`${colLetter(priceImpactCol)}${rowNum}`] = {
                        f: `(${colLetter(nextPriceCol)}${rowNum}-${colLetter(thisPriceCol)}${rowNum})*${colLetter(thisVolCol)}${rowNum}`,
                        t: 'n'
                    };

                    // Volume Impact = (Next Volume - This Volume) √ó This Price
                    ws[`${colLetter(volumeImpactCol)}${rowNum}`] = {
                        f: `(${colLetter(nextVolCol)}${rowNum}-${colLetter(thisVolCol)}${rowNum})*${colLetter(thisPriceCol)}${rowNum}`,
                        t: 'n'
                    };

                    // Mix Impact = (Next Sales - This Sales) - Price Impact - Volume Impact
                    ws[`${colLetter(mixImpactCol)}${rowNum}`] = {
                        f: `(${colLetter(nextSalesCol)}${rowNum}-${colLetter(thisSalesCol)}${rowNum})-${colLetter(priceImpactCol)}${rowNum}-${colLetter(volumeImpactCol)}${rowNum}`,
                        t: 'n'
                    };

                    if (config.mode === 'gm') {
                        // Cost Impact (placeholder for now)
                        const costImpactCol = costImpactStartCol + j;
                        ws[`${colLetter(costImpactCol)}${rowNum}`] = { v: 0, t: 'n' };
                    }
                }
            }
        } else {
            // Two-period mode: original formulas
            const statusCol = dimCount;
            const pySalesCol = dimCount + 1;
            const pyVolCol = dimCount + 2;
            const pyPriceCol = dimCount + 3;
            const cySalesCol = dimCount + 4;
            const cyVolCol = dimCount + 5;
            const cyPriceCol = dimCount + 6;
            const totalChangeCol = dimCount + 7;
            const priceImpactCol = dimCount + 8;
            const volumeImpactCol = dimCount + 9;
            const mixImpactCol = dimCount + 10;

            // Add formulas for each row
            for (let i = 0; i < detail.length; i++) {
                const rowNum = i + 2; // Excel row number (1-indexed, +1 for header)

                const pySales = `${colLetter(pySalesCol)}${rowNum}`;
                const pyVol = `${colLetter(pyVolCol)}${rowNum}`;
                const pyPrice = `${colLetter(pyPriceCol)}${rowNum}`;
                const cySales = `${colLetter(cySalesCol)}${rowNum}`;
                const cyVol = `${colLetter(cyVolCol)}${rowNum}`;
                const cyPrice = `${colLetter(cyPriceCol)}${rowNum}`;
                const totalChange = `${colLetter(totalChangeCol)}${rowNum}`;
                const priceImpact = `${colLetter(priceImpactCol)}${rowNum}`;
                const volumeImpact = `${colLetter(volumeImpactCol)}${rowNum}`;

                // Total Change = CY Sales - PY Sales
                ws[totalChange] = { f: `${cySales}-${pySales}`, t: 'n' };

                // Price Impact = (CY Price - PY Price) √ó PY Volume
                ws[priceImpact] = { f: `(${cyPrice}-${pyPrice})*${pyVol}`, t: 'n' };

                // Volume Impact = (CY Volume - PY Volume) √ó PY Price
                ws[volumeImpact] = { f: `(${cyVol}-${pyVol})*${pyPrice}`, t: 'n' };

                // Mix Impact = Total Change - Price Impact - Volume Impact
                ws[`${colLetter(mixImpactCol)}${rowNum}`] = { f: `${totalChange}-${priceImpact}-${volumeImpact}`, t: 'n' };

                if (config.mode === 'gm') {
                    // Add Cost Impact formula if needed
                    // For now, we'll skip this as it's more complex
                }
            }
        }
        
        // Set column widths
        const cols = [];
        for (let i = 0; i < headerRow.length; i++) {
            if (i < dimensions.length) {
                cols.push({ wch: CONFIG.EXCEL.COL_WIDTH_DIMENSION });
            } else if (headerRow[i] === 'Status') {
                cols.push({ wch: 12 });
            } else if (headerRow[i] === '') {
                // Narrow separator columns
                cols.push({ wch: 2 });
            } else {
                cols.push({ wch: CONFIG.EXCEL.COL_WIDTH_NUMBER });
            }
        }
        ws['!cols'] = cols;

        // Apply number formatting to data cells
        const range = XLSX.utils.decode_range(ws['!ref']);
        for (let R = range.s.r + 1; R <= range.e.r; ++R) {  // Start from row 1 (skip header)
            for (let C = range.s.c; C <= range.e.c; ++C) {
                const cell_address = XLSX.utils.encode_cell({r: R, c: C});
                if (!ws[cell_address] || ws[cell_address].t !== 'n') continue;

                const header = headerRow[C];
                if (!header) continue;

                // Volume columns: comma format without currency
                if (header.includes('Vol') || header.includes('Volume')) {
                    ws[cell_address].z = '#,##0';
                }
                // Sales, Price, Impact, Change columns: currency format
                else if (header.includes('Sales') || header.includes('Price') ||
                         header.includes('Impact') || header.includes('Change') ||
                         header.includes('Œî')) {
                    ws[cell_address].z = '$#,##0';
                }
            }
        }

        // Note: Cell styling (background colors, borders) requires SheetJS Pro.
        // We use blank separator columns (width: 2) between KPI groups for visual separation.
        // Users can manually format the header row in Excel after opening the file.

        // Remove gridlines
        ws['!cols'] = ws['!cols'] || cols;
        ws['!views'] = [{ showGridLines: false }];

        return ws;
    },

    /**
     * Create Negative Values sheet
     * @private
     */
    _createNegativesSheet: function(negatives, stats) {
        const data = [];

        data.push(['Negative Values Analysis']);
        data.push(['Rows with Sales ‚â§ 0 or Quantity ‚â§ 0 are excluded from PVM calculations.']);
        data.push([]);

        // Check if multi-year mode
        const isMultiYear = !negatives.py && !negatives.cy;

        if (isMultiYear) {
            // Multi-year mode: negatives keyed by year
            const years = Object.keys(negatives).sort();
            const headerRow = ['Metric', ...years.map(y => `FY ${y}`), 'Total'];

            // Calculate totals
            let totalCount = 0;
            let totalSales = 0;
            let totalQty = 0;
            let totalCost = 0;

            for (const year of years) {
                totalCount += negatives[year].count;
                totalSales += negatives[year].sales;
                totalQty += negatives[year].quantity;
                totalCost += negatives[year].cost;
            }

            data.push(['Summary']);
            data.push(headerRow);

            data.push(['Excluded Row Count', ...years.map(y => negatives[y].count), totalCount]);
            data.push(['Excluded Sales Total', ...years.map(y => negatives[y].sales), totalSales]);
            data.push(['Excluded Quantity Total', ...years.map(y => negatives[y].quantity), totalQty]);
            data.push(['Excluded Cost Total', ...years.map(y => negatives[y].cost), totalCost]);
            data.push([]);

            // Processing stats
            data.push(['Processing Statistics']);
            data.push(['Metric', 'Value']);
            data.push(['Total Rows Read', stats.totalRows]);
            data.push(['Rows Included in Analysis', stats.includedRows]);
            data.push(['Rows Excluded (negative/zero)', totalCount]);
            data.push(['Rows Outside Analysis Periods', stats.outsidePeriodRows]);
            data.push(['Rows with Parse Errors', stats.parseErrors]);

        } else {
            // Two-period mode: original behavior
            data.push(['Summary']);
            data.push(['Metric', 'Prior Year', 'Current Year / LTM', 'Total']);
            data.push([
                'Excluded Row Count',
                negatives.py.count,
                negatives.cy.count,
                negatives.py.count + negatives.cy.count
            ]);
            data.push([
                'Excluded Sales Total',
                negatives.py.sales,
                negatives.cy.sales,
                negatives.py.sales + negatives.cy.sales
            ]);
            data.push([
                'Excluded Quantity Total',
                negatives.py.quantity,
                negatives.cy.quantity,
                negatives.py.quantity + negatives.cy.quantity
            ]);
            data.push([
                'Excluded Cost Total',
                negatives.py.cost,
                negatives.cy.cost,
                negatives.py.cost + negatives.cy.cost
            ]);
            data.push([]);

            // Processing stats
            data.push(['Processing Statistics']);
            data.push(['Metric', 'Value']);
            data.push(['Total Rows Read', stats.totalRows]);
            data.push(['Rows Included in Analysis', stats.includedRows]);
            data.push(['Rows Excluded (negative/zero)', negatives.py.count + negatives.cy.count]);
            data.push(['Rows Outside Analysis Periods', stats.outsidePeriodRows]);
            data.push(['Rows with Parse Errors', stats.parseErrors]);
        }

        const ws = XLSX.utils.aoa_to_sheet(data);

        ws['!cols'] = [
            { wch: 25 },
            { wch: 18 },
            { wch: 18 },
            { wch: 18 }
        ];

        return ws;
    },

    /**
     * Create Assumptions sheet
     * @private
     */
    _createAssumptionsSheet: function(config, stats, mode) {
        const data = [];
        const methodology = BridgeCalculator.getMethodologyDescription(mode, config.gmPriceDefinition);

        data.push(['Analysis Assumptions & Methodology']);
        data.push([`Generated: ${new Date().toLocaleString()}`]);
        data.push([]);

        // Configuration
        data.push(['Analysis Configuration']);
        data.push(['Parameter', 'Value']);
        data.push(['Analysis Mode', mode === 'gm' ? 'Gross Margin Bridge' : 'Sales PVM Bridge']);

        if (mode === 'gm') {
            data.push(['GM Price Definition',
                config.gmPriceDefinition === 'margin-per-unit' ?
                    'Margin per Unit: (Sales - Cost) / Quantity' :
                    'Sales per Unit: Sales / Quantity'
            ]);
        }

        data.push(['Fiscal Year End Month', CONFIG.MONTH_NAMES[config.fyEndMonth - 1]]);

        // Add period information based on mode
        if (config.fiscalYears && config.fiscalYears.length > 0) {
            // Multi-year mode
            const yearLabels = config.fiscalYears.map(fy => fy.label || `FY ${fy.fiscalYear}`).join(', ');
            const firstYear = config.fiscalYears[0];
            const lastYear = config.fiscalYears[config.fiscalYears.length - 1];
            data.push(['Analysis Type', 'Multi-Year Comparison']);
            data.push(['Fiscal Years', yearLabels]);
            data.push(['Date Range', `${PeriodUtils.formatDate(firstYear.start)} to ${PeriodUtils.formatDate(lastYear.end)}`]);
        } else if (config.pyRange && config.cyRange) {
            // Two-period mode
            data.push(['Prior Year Period', PeriodUtils.formatDateRange(config.pyRange.start, config.pyRange.end)]);
            data.push(['LTM Period', PeriodUtils.formatDateRange(config.cyRange.start, config.cyRange.end)]);
        }

        data.push(['Level of Detail Dimensions', config.dimensions.length > 0 ? config.dimensions.join(', ') : 'Total Only']);
        data.push([]);
        
        // Column mappings
        data.push(['Column Mappings']);
        data.push(['Field', 'Source Column']);
        data.push(['Date', config.dateColumn]);
        data.push(['Sales', config.salesColumn]);
        data.push(['Quantity', config.quantityColumn]);
        if (config.costColumn) {
            data.push(['Cost', config.costColumn]);
        }
        data.push([]);
        
        // Methodology
        data.push(['Calculation Methodology']);
        data.push([methodology.title]);
        data.push([methodology.description]);
        data.push([]);
        
        data.push(['Formulas Used']);
        for (const f of methodology.formulas) {
            data.push([f.name, f.formula]);
        }
        data.push([]);
        
        // Rules
        data.push(['Business Rules Applied']);
        for (const note of methodology.notes) {
            data.push([note]);
        }
        data.push([]);
        
        // Data quality
        data.push(['Data Quality Notes']);
        data.push([`Total rows processed: ${stats.totalRows.toLocaleString()}`]);
        data.push([`Rows included in analysis: ${stats.includedRows.toLocaleString()}`]);
        data.push([`Rows excluded (negative/zero values): ${stats.excludedRows.toLocaleString()}`]);
        
        if (stats.outsidePeriodRows > 0) {
            data.push([`Rows outside analysis periods: ${stats.outsidePeriodRows.toLocaleString()}`]);
        }
        if (stats.parseErrors > 0) {
            data.push([`Rows with parse errors: ${stats.parseErrors.toLocaleString()}`]);
        }
        
        data.push([`Unique LOD combinations: ${stats.uniqueLODKeys.toLocaleString()}`]);
        data.push([]);
        
        // Reconciliation check
        data.push(['Reconciliation Check']);
        data.push(['The sum of Price Impact + Volume Impact + Mix Impact should equal Total Change.']);
        data.push(['Mix Impact is calculated as the residual to ensure exact reconciliation.']);
        
        const ws = XLSX.utils.aoa_to_sheet(data);
        
        ws['!cols'] = [
            { wch: 40 },
            { wch: 50 }
        ];
        
        return ws;
    }
};

if (typeof module !== 'undefined' && module.exports) {
    module.exports = ExcelExport;
}

// ============================================
// app.js
// ============================================
/**
 * ============================================
 * PVM Bridge Tool - Main Application
 * ============================================
 * Orchestrates UI flow, state, and modules.
 * ============================================
 */

const App = {
    state: {
        mode: 'pvm',
        file: null,
        isExcelFile: false,
        headers: [],
        sampleRows: [],
        columnMappings: { date: null, sales: null, quantity: null, cost: null, dimensions: [] },
        dateFormat: null,
        detectedDateFormat: null,
        fyEndMonth: 12,
        useLTM: true,
        ltmEndDate: null,
        pyFiscalYear: null,
        cyFiscalYear: null,
        pyRange: null,
        cyRange: null,
        pyLabel: '',
        cyLabel: '',
        dataDateRange: { min: null, max: null },
        selectedDimensions: [],
        gmPriceDefinition: 'margin-per-unit',
        aggregationResults: null,
        bridgeResults: null,
        isProcessing: false,
        shouldCancel: false,
        currentPage: 1,
        sortBy: 'total-desc',
        searchTerm: '',
        // Multi-year support
        detectedFiscalYears: [],
        selectedFiscalYears: [],
        hasMultipleYears: false,
        useMultiYearMode: false
    },

    init: function() {
        this.loadPreferences();
        this.bindEvents();
        this.showScreen('screen-landing');
    },

    loadPreferences: function() {
        try {
            const saved = localStorage.getItem(CONFIG.STORAGE_KEYS.LAST_CONFIG);
            if (saved) {
                const prefs = JSON.parse(saved);
                if (prefs.fyEndMonth) this.state.fyEndMonth = prefs.fyEndMonth;
                if (prefs.mode) this.state.mode = prefs.mode;
            }
        } catch (e) {}
    },

    savePreferences: function() {
        try {
            localStorage.setItem(CONFIG.STORAGE_KEYS.LAST_CONFIG, JSON.stringify({
                fyEndMonth: this.state.fyEndMonth,
                mode: this.state.mode
            }));
        } catch (e) {}
    },

    formatFileSize: function(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
    },

    showScreen: function(screenId) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(screenId).classList.add('active');

        const modeLabel = this.state.mode === 'gm' ? 'Gross Margin Mode' : 'Sales PVM Mode';
        document.querySelectorAll('.mode-indicator').forEach(el => el.textContent = modeLabel);
        document.querySelectorAll('.gm-only').forEach(el => el.classList.toggle('hidden', this.state.mode !== 'gm'));
        document.getElementById('gm-price-definition').classList.toggle('hidden', this.state.mode !== 'gm');
    },

    togglePeriodSections: function() {
        const useLTM = this.state.useLTM;
        document.getElementById('ltm-config-section').style.display = useLTM ? 'block' : 'none';
        document.getElementById('cy-fiscal-year-section').style.display = useLTM ? 'none' : 'block';
    },

    bindEvents: function() {
        // Mode selection
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const b = e.target.closest('.mode-btn');
                if (!b) return;
                document.querySelectorAll('.mode-btn').forEach(x => x.classList.remove('selected'));
                b.classList.add('selected');
                this.state.mode = b.dataset.mode;
                this.savePreferences();
            });
        });

        // Navigation
        document.getElementById('btn-start').addEventListener('click', () => this.showScreen('screen-upload'));
        document.getElementById('btn-to-periods').addEventListener('click', () => this.goToPeriods());
        document.getElementById('btn-to-lod').addEventListener('click', () => this.goToLOD());
        document.getElementById('btn-process').addEventListener('click', () => this.startProcessing());
        document.getElementById('btn-cancel').addEventListener('click', () => this.cancelProcessing());
        document.getElementById('btn-export-excel').addEventListener('click', () => this.exportExcel());

        document.querySelectorAll('.btn-back').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const target = e.target.dataset.target;
                if (target) this.showScreen(target);
            });
        });

        // File upload
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('drag-over'); });
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('drag-over'));
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) this.handleFileSelect(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) this.handleFileSelect(e.target.files[0]);
        });

        document.getElementById('btn-remove-file').addEventListener('click', () => this.removeFile());

        document.querySelectorAll('.column-select').forEach(select => {
            select.addEventListener('change', (e) => this.handleColumnMappingChange(e));
        });

        document.getElementById('date-format-select').addEventListener('change', (e) => {
            this.state.dateFormat = e.target.value === 'auto' ? this.state.detectedDateFormat?.formatId : e.target.value;
            this.updateDateParsePreview();
            this.validateColumnMappings();
        });

        document.getElementById('fy-end-month').addEventListener('change', (e) => {
            this.state.fyEndMonth = parseInt(e.target.value, 10);

            // Re-detect fiscal years if we have date range data
            if (this.state.dataDateRange.min && this.state.dataDateRange.max) {
                const fiscalYears = PeriodUtils.detectFiscalYears(
                    this.state.dataDateRange.min,
                    this.state.dataDateRange.max,
                    this.state.fyEndMonth
                );
                this.state.detectedFiscalYears = fiscalYears;
                this.state.hasMultipleYears = fiscalYears.length >= 2;

                // If we have multiple years (even partial), show multi-year selection
                if (fiscalYears.length >= 2) {
                    // Reset selected years when FY end changes
                    this.state.selectedFiscalYears = [];
                    this.showMultiYearSelection(fiscalYears);
                } else {
                    // Switch to two-period mode
                    document.getElementById('multi-year-section').style.display = 'none';
                    document.getElementById('two-period-config').style.display = 'block';
                    this.state.useMultiYearMode = false;
                    this.updatePeriodPreviews();
                }
            } else {
                this.updatePeriodPreviews();
            }

            this.savePreferences();
        });

        document.getElementById('ltm-end-date').addEventListener('change', (e) => {
            this.state.ltmEndDate = PeriodUtils.fromISODateString(e.target.value);
            this.updatePeriodPreviews();
        });

        document.getElementById('use-ltm-period').addEventListener('change', (e) => {
            this.state.useLTM = e.target.checked;
            this.togglePeriodSections();
            this.updatePeriodPreviews();
        });

        document.getElementById('cy-fiscal-year').addEventListener('change', (e) => {
            this.state.cyFiscalYear = parseInt(e.target.value, 10);
            this.updatePeriodPreviews();
        });

        document.querySelectorAll('input[name="gm-price-def"]').forEach(radio => {
            radio.addEventListener('change', (e) => this.state.gmPriceDefinition = e.target.value);
        });

        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => this.switchTab(e.target.dataset.tab));
        });

        document.getElementById('detail-search').addEventListener('input', (e) => {
            this.state.searchTerm = e.target.value;
            this.state.currentPage = 1;
            this.renderDetailTable();
        });

        document.getElementById('detail-sort').addEventListener('change', (e) => {
            this.state.sortBy = e.target.value;
            this.renderDetailTable();
        });

        document.getElementById('detail-pagination').addEventListener('click', (e) => {
            if (e.target.dataset.page) {
                this.state.currentPage = parseInt(e.target.dataset.page, 10);
                this.renderDetailTable();
            }
        });

        document.getElementById('error-modal-close').addEventListener('click', () => UIRenderer.hideError());
        document.getElementById('error-modal-ok').addEventListener('click', () => UIRenderer.hideError());
    },

    async handleFileSelect(file) {
        const fileName = file.name.toLowerCase();
        const isExcel = fileName.endsWith('.xlsx') || fileName.endsWith('.xls');
        const isCsv = fileName.endsWith('.csv');

        if (!isExcel && !isCsv) {
            UIRenderer.showError('Please select a CSV or Excel file (.csv, .xlsx, .xls)');
            return;
        }

        this.state.file = file;
        this.state.isExcelFile = isExcel;
        document.getElementById('file-info').classList.remove('hidden');
        document.getElementById('file-name').textContent = file.name;
        document.getElementById('file-size').textContent = this.formatFileSize(file.size);

        try {
            // Use appropriate parser based on file type
            const parser = isExcel ? ExcelParser : CSVParser;
            const { headers, sampleRows } = await parser.scanFile(file, 100);
            this.state.headers = headers;
            this.state.sampleRows = sampleRows;

            const mappings = CSVParser.detectColumnMappings(headers, sampleRows);
            this.state.columnMappings = mappings;
            
            this.populateColumnMappings();
            document.getElementById('column-mapping').classList.remove('hidden');
            this.validateColumnMappings();
        } catch (error) {
            UIRenderer.showError('Error reading file: ' + error.message);
        }
    },

    removeFile: function() {
        this.state.file = null;
        this.state.headers = [];
        this.state.sampleRows = [];
        document.getElementById('file-info').classList.add('hidden');
        document.getElementById('column-mapping').classList.add('hidden');
        document.getElementById('file-input').value = '';
        document.getElementById('btn-to-periods').disabled = true;
    },

    populateColumnMappings: function() {
        const headers = this.state.headers;
        const mappings = this.state.columnMappings;
        
        for (const field of ['date', 'sales', 'quantity', 'cost']) {
            const select = document.getElementById(`map-${field}`);
            UIRenderer.clearElement(select);
            select.appendChild(UIRenderer.createElement('option', { value: '' }, ['-- Select --']));
            
            for (const header of headers) {
                const opt = UIRenderer.createElement('option', { value: header }, [header]);
                if (mappings[field] === header) opt.selected = true;
                select.appendChild(opt);
            }
        }
        
        const dimContainer = document.getElementById('dimension-checkboxes');
        UIRenderer.clearElement(dimContainer);
        
        for (const header of headers) {
            const isRequired = [mappings.date, mappings.sales, mappings.quantity, mappings.cost].includes(header);
            const label = UIRenderer.createElement('label', { className: 'checkbox-label' });
            const checkbox = UIRenderer.createElement('input', {
                type: 'checkbox',
                value: header,
                checked: mappings.dimensions.includes(header) ? 'checked' : null,
                disabled: isRequired ? 'disabled' : null
            });
            checkbox.addEventListener('change', () => this.updateDimensionMappings());
            label.appendChild(checkbox);
            label.appendChild(UIRenderer.text(header + (isRequired ? ' (mapped)' : '')));
            dimContainer.appendChild(label);
        }
        
        if (mappings.date) this.detectAndShowDateFormat(mappings.date);
    },

    handleColumnMappingChange: function(e) {
        const field = e.target.dataset.field;
        const value = e.target.value || null;
        this.state.columnMappings[field] = value;
        this.populateColumnMappings();
        if (field === 'date' && value) this.detectAndShowDateFormat(value);
        this.validateColumnMappings();
    },

    updateDimensionMappings: function() {
        const checkboxes = document.querySelectorAll('#dimension-checkboxes input[type="checkbox"]');
        this.state.columnMappings.dimensions = [];
        checkboxes.forEach(cb => {
            if (cb.checked && !cb.disabled) this.state.columnMappings.dimensions.push(cb.value);
        });
    },

    detectAndShowDateFormat: function(dateColumn) {
        // Use appropriate parser based on file type
        const parser = this.state.isExcelFile ? ExcelParser : CSVParser;
        const samples = parser.extractDateSamples(this.state.sampleRows, dateColumn);
        if (samples.length === 0) {
            document.getElementById('date-format-section').classList.add('hidden');
            return;
        }

        const detected = PeriodUtils.detectDateFormat(samples);
        this.state.detectedDateFormat = detected;
        this.state.dateFormat = detected.formatId;

        const sampleList = document.getElementById('date-samples');
        UIRenderer.clearElement(sampleList);
        for (const sample of samples.slice(0, 5)) {
            sampleList.appendChild(UIRenderer.createElement('li', {}, [sample]));
        }

        document.getElementById('date-format-select').value = detected.formatId || 'auto';
        this.updateDateParsePreview();
        document.getElementById('date-format-section').classList.remove('hidden');
    },

    updateDateParsePreview: function() {
        const preview = document.getElementById('date-parse-preview');
        // Use appropriate parser based on file type
        const parser = this.state.isExcelFile ? ExcelParser : CSVParser;
        const samples = parser.extractDateSamples(this.state.sampleRows, this.state.columnMappings.date);
        
        if (samples.length === 0 || !this.state.dateFormat) { preview.textContent = ''; return; }
        
        const parsed = PeriodUtils.parseDate(samples[0], this.state.dateFormat);
        if (parsed) {
            preview.textContent = `‚úì Parsed as: ${PeriodUtils.formatDate(parsed, 'long')}`;
            preview.classList.remove('error');
        } else {
            preview.textContent = '‚úó Could not parse - select correct format';
            preview.classList.add('error');
        }
    },

    validateColumnMappings: function() {
        const m = this.state.columnMappings;
        let valid = m.date && m.sales && m.quantity;
        if (this.state.mode === 'gm' && !m.cost) valid = false;
        if (!this.state.dateFormat) valid = false;
        document.getElementById('btn-to-periods').disabled = !valid;
    }
};

// Initialize on DOM ready
document.addEventListener('DOMContentLoaded', () => App.init());

// ============================================
// app2.js
// ============================================
/**
 * ============================================
 * PVM Bridge Tool - Application Part 2
 * Processing, Results, and Export
 * ============================================
 */

// Extend App object with additional methods
Object.assign(App, {
    async goToPeriods() {
        this.updateDimensionMappings();
        this.showScreen('screen-periods');
        document.getElementById('fy-end-month').value = this.state.fyEndMonth;
        document.getElementById('date-range-info').innerHTML = '<p>Scanning file for date range...</p>';
        await this.scanDateRange();
    },

    async scanDateRange() {
        const dateColumn = this.state.columnMappings.date;
        const dateFormat = this.state.dateFormat;
        let minDate = null, maxDate = null, rowCount = 0;

        // Use appropriate parser based on file type
        const parser = this.state.isExcelFile ? ExcelParser : CSVParser;
        await parser.parseFile(this.state.file, {
            onRow: (row) => {
                rowCount++;
                const date = PeriodUtils.parseDate(row[dateColumn], dateFormat);
                if (date) {
                    if (!minDate || date < minDate) minDate = new Date(date);
                    if (!maxDate || date > maxDate) maxDate = new Date(date);
                }
            },
            onComplete: () => {
                this.state.dataDateRange = { min: minDate, max: maxDate };
                const info = document.getElementById('date-range-info');
                if (minDate && maxDate) {
                    // Detect fiscal years in the data
                    const fiscalYears = PeriodUtils.detectFiscalYears(minDate, maxDate, this.state.fyEndMonth);
                    this.state.detectedFiscalYears = fiscalYears;

                    // Check if multi-year mode should be enabled
                    const fullYears = fiscalYears.filter(y => y.fullyCovered);
                    this.state.hasMultipleYears = fullYears.length >= 2;

                    let dateRangeHTML = `<p><strong>Date Range:</strong> ${PeriodUtils.formatDate(minDate)} to ${PeriodUtils.formatDate(maxDate)}</p>
                        <p><strong>Total Rows:</strong> ${rowCount.toLocaleString()}</p>`;

                    // Show detected fiscal years
                    if (fiscalYears.length >= 2) {
                        const yearLabels = fiscalYears.map(y => y.label).join(', ');
                        const completeCount = fullYears.length;
                        const partialCount = fiscalYears.length - completeCount;

                        dateRangeHTML += `<p><strong>Detected Fiscal Years:</strong> ${yearLabels}</p>`;
                        if (completeCount >= 2) {
                            dateRangeHTML += `<p style="color: var(--color-success); font-weight: 600;">‚úì Multi-year analysis available (${completeCount} complete, ${partialCount} partial)</p>`;
                        } else if (completeCount === 1) {
                            dateRangeHTML += `<p style="color: var(--color-info);">‚ö† ${completeCount} complete year, ${partialCount} partial. You can still analyze partial years.</p>`;
                        } else {
                            dateRangeHTML += `<p style="color: var(--color-warning);">‚ö† All years have partial data. Results may be incomplete.</p>`;
                        }

                        // Show multi-year section with ALL fiscal years (including partial)
                        this.showMultiYearSelection(fiscalYears);
                    } else if (fiscalYears.length === 1) {
                        dateRangeHTML += `<p><strong>Detected:</strong> ${fiscalYears[0].label}</p>`;

                        // Show two-period config and hide multi-year section
                        document.getElementById('multi-year-section').style.display = 'none';
                        document.getElementById('two-period-config').style.display = 'block';
                    } else {
                        // No fiscal years detected, show two-period config
                        document.getElementById('multi-year-section').style.display = 'none';
                        document.getElementById('two-period-config').style.display = 'block';
                    }

                    info.innerHTML = dateRangeHTML;

                    // Set default LTM end date
                    this.state.ltmEndDate = maxDate;
                    document.getElementById('ltm-end-date').value = PeriodUtils.toISODateString(maxDate);

                    // Set default current fiscal year based on max date
                    const maxYear = maxDate.getFullYear();
                    const maxMonth = maxDate.getMonth() + 1;
                    const fyEndMonth = this.state.fyEndMonth;
                    // If we're past the FY end month, we're in the next fiscal year
                    const currentFY = maxMonth > fyEndMonth ? maxYear + 1 : maxYear;
                    this.state.cyFiscalYear = currentFY;
                    document.getElementById('cy-fiscal-year').value = currentFY;

                    this.updatePeriodPreviews();
                } else {
                    info.innerHTML = '<p>Could not determine date range.</p>';
                }
            },
            onError: (error) => {
                document.getElementById('date-range-info').innerHTML = `<p>Error: ${error.message}</p>`;
            }
        });
    },

    showMultiYearSelection(fiscalYears) {
        // Show multi-year section, hide two-period config
        document.getElementById('multi-year-section').style.display = 'block';
        document.getElementById('two-period-config').style.display = 'none';

        // Populate fiscal year checkboxes
        const container = document.getElementById('fiscal-year-checkboxes');
        UIRenderer.clearElement(container);

        // Initialize selected years if not already set (default to all years)
        if (!this.state.selectedFiscalYears || this.state.selectedFiscalYears.length === 0) {
            this.state.selectedFiscalYears = fiscalYears.map(fy => fy.fiscalYear);
        }

        for (const fyConfig of fiscalYears) {
            const isChecked = this.state.selectedFiscalYears.includes(fyConfig.fiscalYear);

            const label = UIRenderer.createElement('label', { className: 'fiscal-year-option' });

            const checkbox = UIRenderer.createElement('input', {
                type: 'checkbox',
                value: fyConfig.fiscalYear,
                checked: isChecked ? 'checked' : null,
                'data-fy-start': PeriodUtils.toISODateString(fyConfig.start),
                'data-fy-end': PeriodUtils.toISODateString(fyConfig.end)
            });

            checkbox.addEventListener('change', () => this.updateFiscalYearSelection());

            const textContainer = UIRenderer.createElement('div');

            // Add warning icon if not fully covered
            const labelText = fyConfig.fullyCovered ? fyConfig.label : `${fyConfig.label} ‚ö†`;
            const fyLabel = UIRenderer.createElement('div', { className: 'fy-label' }, [labelText]);

            const dateRangeText = fyConfig.fullyCovered ?
                `${PeriodUtils.formatDate(fyConfig.start)} - ${PeriodUtils.formatDate(fyConfig.end)}` :
                `${PeriodUtils.formatDate(fyConfig.start)} - ${PeriodUtils.formatDate(fyConfig.end)} (partial)`;

            const dateRange = UIRenderer.createElement('div', { className: 'fy-date-range' }, [dateRangeText]);

            textContainer.appendChild(fyLabel);
            textContainer.appendChild(dateRange);
            label.appendChild(checkbox);
            label.appendChild(textContainer);
            container.appendChild(label);
        }

        this.updateFiscalYearSelection();
    },

    updateFiscalYearSelection() {
        const checkboxes = document.querySelectorAll('#fiscal-year-checkboxes input[type="checkbox"]');
        this.state.selectedFiscalYears = [];

        checkboxes.forEach(cb => {
            if (cb.checked) {
                this.state.selectedFiscalYears.push(Number(cb.value));
            }
        });

        // Sort selected years
        this.state.selectedFiscalYears.sort((a, b) => a - b);

        // Update summary and validation
        const summary = document.getElementById('period-summary');
        const btnContinue = document.getElementById('btn-to-lod');

        if (this.state.selectedFiscalYears.length < 2) {
            summary.innerHTML = '<p style="color: var(--color-warning);">‚ö†Ô∏è Please select at least 2 fiscal years for multi-year analysis.</p>';
            btnContinue.disabled = true;
        } else {
            const selectedYearObjs = this.state.detectedFiscalYears.filter(fy =>
                this.state.selectedFiscalYears.includes(fy.fiscalYear)
            );

            const yearLabels = selectedYearObjs.map(fy => fy.label).join(', ');
            const firstYear = selectedYearObjs[0];
            const lastYear = selectedYearObjs[selectedYearObjs.length - 1];

            summary.innerHTML = `<p><strong>Multi-Year Analysis:</strong></p>
                <p>Selected Years: ${yearLabels}</p>
                <p>Period: ${PeriodUtils.formatDate(firstYear.start)} to ${PeriodUtils.formatDate(lastYear.end)}</p>
                <p style="color: var(--color-success);">‚úì ${this.state.selectedFiscalYears.length} fiscal years selected</p>`;

            btnContinue.disabled = false;

            // Update state to use multi-year mode
            this.state.useMultiYearMode = true;
        }
    },

    updatePeriodPreviews() {
        const { fyEndMonth, ltmEndDate, useLTM, cyFiscalYear } = this.state;

        // Skip if we're in multi-year mode
        if (this.state.useMultiYearMode) {
            return;
        }

        let cyRange, pyRange, currentFY, priorFY;

        if (useLTM) {
            // LTM mode
            if (!ltmEndDate) return;

            cyRange = PeriodUtils.getLTMRange(ltmEndDate);
            this.state.cyRange = cyRange;

            priorFY = PeriodUtils.getPriorFiscalYear(ltmEndDate, fyEndMonth);
            pyRange = PeriodUtils.getFiscalYearRange(priorFY, fyEndMonth);
            this.state.pyRange = pyRange;

            // Store fiscal year labels
            this.state.pyFiscalYear = priorFY;
            this.state.pyLabel = `FY ${priorFY}`;
            this.state.cyLabel = 'LTM';

            document.getElementById('ltm-range-preview').textContent = PeriodUtils.formatDateRange(cyRange.start, cyRange.end);
            document.getElementById('pfy-range').textContent = `FY ${priorFY}: ${PeriodUtils.formatDateRange(pyRange.start, pyRange.end)}`;

            const summary = document.getElementById('period-summary');
            summary.innerHTML = `<p><strong>Comparison:</strong></p>
                <p>Prior Year (FY ${priorFY}): ${PeriodUtils.formatDateRange(pyRange.start, pyRange.end)}</p>
                <p>vs. LTM: ${PeriodUtils.formatDateRange(cyRange.start, cyRange.end)}</p>`;

            const validation = PeriodUtils.validatePeriodConfig({ fyEndMonth, ltmEndDate, pyRange, cyRange });
            if (validation.warnings.length > 0) {
                summary.innerHTML += `<p style="color: var(--color-warning);">‚ö†Ô∏è ${validation.warnings.join(' ')}</p>`;
            }
            document.getElementById('btn-to-lod').disabled = !validation.valid;

        } else {
            // Fiscal Year mode
            if (!cyFiscalYear) return;

            currentFY = cyFiscalYear;
            priorFY = currentFY - 1;

            cyRange = PeriodUtils.getFiscalYearRange(currentFY, fyEndMonth);
            this.state.cyRange = cyRange;

            pyRange = PeriodUtils.getFiscalYearRange(priorFY, fyEndMonth);
            this.state.pyRange = pyRange;

            // Store fiscal year labels
            this.state.pyFiscalYear = priorFY;
            this.state.cyFiscalYear = currentFY;
            this.state.pyLabel = `FY ${priorFY}`;
            this.state.cyLabel = `FY ${currentFY}`;

            document.getElementById('cy-range-preview').textContent = `FY ${currentFY}: ${PeriodUtils.formatDateRange(cyRange.start, cyRange.end)}`;
            document.getElementById('pfy-range').textContent = `FY ${priorFY}: ${PeriodUtils.formatDateRange(pyRange.start, pyRange.end)}`;

            const summary = document.getElementById('period-summary');
            summary.innerHTML = `<p><strong>Comparison:</strong></p>
                <p>Prior Year (FY ${priorFY}): ${PeriodUtils.formatDateRange(pyRange.start, pyRange.end)}</p>
                <p>vs. Current Year (FY ${currentFY}): ${PeriodUtils.formatDateRange(cyRange.start, cyRange.end)}</p>`;

            // Validate (no warnings for fiscal year mode typically)
            document.getElementById('btn-to-lod').disabled = false;
        }
    },

    goToLOD() {
        this.showScreen('screen-lod');
        const container = document.getElementById('lod-selection');
        UIRenderer.clearElement(container);

        const dimensions = this.state.columnMappings.dimensions;
        if (dimensions.length === 0) {
            container.innerHTML = '<p class="text-muted">No dimensions available. Analysis at total level.</p>';
        } else {
            for (const dim of dimensions) {
                const label = UIRenderer.createElement('label', { className: 'checkbox-label' });
                const checkbox = UIRenderer.createElement('input', {
                    type: 'checkbox', value: dim,
                    checked: this.state.selectedDimensions.includes(dim) ? 'checked' : null
                });
                checkbox.addEventListener('change', () => this.updateLODSelection());
                label.appendChild(checkbox);
                label.appendChild(UIRenderer.text(dim));
                container.appendChild(label);
            }
        }
        this.updateLODSelection();
    },

    updateLODSelection() {
        const checkboxes = document.querySelectorAll('#lod-selection input[type="checkbox"]');
        this.state.selectedDimensions = [];
        checkboxes.forEach(cb => { if (cb.checked) this.state.selectedDimensions.push(cb.value); });

        const preview = document.getElementById('lod-preview-text');
        const warning = document.getElementById('lod-warning');

        if (this.state.selectedDimensions.length === 0) {
            preview.textContent = 'Analysis will be at total level (no dimensions).';
            warning.classList.add('hidden');
        } else {
            preview.textContent = `Analysis by: ${this.state.selectedDimensions.join(' ‚Üí ')}`;
            warning.classList.toggle('hidden', this.state.selectedDimensions.length <= CONFIG.VALIDATION.MAX_RECOMMENDED_DIMENSIONS);
        }
    },

    async startProcessing() {
        this.state.isProcessing = true;
        this.state.shouldCancel = false;
        this.showScreen('screen-processing');

        // Reset progress UI
        document.getElementById('progress-fill').style.width = '0%';
        document.getElementById('progress-percent').textContent = '0%';
        document.getElementById('progress-rows').textContent = '0 rows';
        document.querySelectorAll('.stage').forEach(s => {
            s.classList.remove('active', 'complete');
            s.querySelector('.stage-icon').textContent = '‚è≥';
        });

        const setStage = (id, status) => {
            const stage = document.getElementById(id);
            stage.classList.remove('active', 'complete');
            if (status === 'active') stage.classList.add('active');
            if (status === 'complete') {
                stage.classList.add('complete');
                stage.querySelector('.stage-icon').textContent = '‚úì';
            }
        };

        try {
            // Stage 1: Parsing & Aggregating
            setStage('stage-parsing', 'active');

            // Determine if multi-year mode should be used
            const useMultiYear = this.state.useMultiYearMode && this.state.selectedFiscalYears && this.state.selectedFiscalYears.length >= 2;
            let selectedFiscalYearConfigs = [];

            if (useMultiYear) {
                // Get the fiscal year configs for selected years only
                selectedFiscalYearConfigs = this.state.detectedFiscalYears.filter(fy =>
                    this.state.selectedFiscalYears.includes(fy.fiscalYear)
                );
            }

            const aggregatorConfig = {
                dimensions: this.state.selectedDimensions,
                dateColumn: this.state.columnMappings.date,
                salesColumn: this.state.columnMappings.sales,
                quantityColumn: this.state.columnMappings.quantity,
                costColumn: this.state.columnMappings.cost,
                dateFormat: this.state.dateFormat,
                fyEndMonth: this.state.fyEndMonth
            };

            if (useMultiYear) {
                // Multi-year mode: pass selected fiscal years
                aggregatorConfig.fiscalYears = selectedFiscalYearConfigs;
            } else {
                // Two-period mode: pass pyRange and cyRange
                aggregatorConfig.pyRange = this.state.pyRange;
                aggregatorConfig.cyRange = this.state.cyRange;
            }

            const ctx = Aggregator.createContext(aggregatorConfig);

            // Use appropriate parser based on file type
            const parser = this.state.isExcelFile ? ExcelParser : CSVParser;
            await parser.parseFile(this.state.file, {
                onRow: (row, rowNum) => {
                    Aggregator.processRow(ctx, row);
                },
                onProgress: (bytes, total, rows) => {
                    const pct = Math.round((bytes / total) * 100);
                    document.getElementById('progress-fill').style.width = pct + '%';
                    document.getElementById('progress-percent').textContent = pct + '%';
                    document.getElementById('progress-rows').textContent = rows.toLocaleString() + ' rows';
                },
                shouldCancel: () => this.state.shouldCancel,
                onComplete: (result) => {
                    if (result.cancelled) {
                        this.showScreen('screen-lod');
                        return;
                    }
                    setStage('stage-parsing', 'complete');
                    setStage('stage-aggregating', 'complete');
                },
                onError: (error) => {
                    UIRenderer.showError('Processing error: ' + error.message);
                    this.showScreen('screen-lod');
                }
            });

            if (this.state.shouldCancel) return;

            // Stage 2: Calculate Bridge
            setStage('stage-calculating', 'active');
            
            const aggregationResults = Aggregator.finalize(ctx);
            this.state.aggregationResults = aggregationResults;

            const bridgeCalcOptions = {
                mode: this.state.mode,
                gmPriceDefinition: this.state.gmPriceDefinition,
                isMultiYear: aggregationResults.isMultiYear
            };

            if (aggregationResults.isMultiYear) {
                bridgeCalcOptions.fiscalYears = selectedFiscalYearConfigs;
            }

            const bridgeResults = BridgeCalculator.calculate(aggregationResults.data, bridgeCalcOptions);
            this.state.bridgeResults = bridgeResults;

            setStage('stage-calculating', 'complete');

            // Stage 3: Finalize
            setStage('stage-finalizing', 'active');
            
            // Small delay for UI
            await new Promise(r => setTimeout(r, 200));
            
            setStage('stage-finalizing', 'complete');

            // Show results
            this.showResults();

        } catch (error) {
            UIRenderer.showError('Error: ' + error.message);
            this.showScreen('screen-lod');
        } finally {
            this.state.isProcessing = false;
        }
    },

    cancelProcessing() {
        this.state.shouldCancel = true;
    },

    showResults() {
        this.showScreen('screen-results');

        const { bridgeResults, aggregationResults, pyRange, cyRange, mode, gmPriceDefinition, selectedDimensions } = this.state;
        const summary = bridgeResults.summary;

        // Check if multi-year mode
        const isMultiYear = aggregationResults.isMultiYear;
        const fiscalYears = isMultiYear && this.state.selectedFiscalYears ?
            this.state.detectedFiscalYears.filter(fy => this.state.selectedFiscalYears.includes(fy.fiscalYear)) :
            [];

        // Period labels
        let pyLabel, cyLabel;
        if (isMultiYear) {
            // In multi-year mode, labels are handled differently (first year, last year)
            pyLabel = '';
            cyLabel = '';
        } else {
            pyLabel = pyRange ? PeriodUtils.formatDateRange(pyRange.start, pyRange.end) : '';
            cyLabel = cyRange ? PeriodUtils.formatDateRange(cyRange.start, cyRange.end) : '';
        }

        // Summary cards
        UIRenderer.renderSummaryCards(summary, pyLabel, cyLabel);

        // Bridge summary table
        UIRenderer.renderBridgeSummary(summary, mode, aggregationResults.negatives);

        // Bridge waterfall chart
        UIRenderer.renderBridgeChart(summary, mode);

        // Detail table
        UIRenderer.renderDetailTableHeader(selectedDimensions, mode, this.state.pyLabel, this.state.cyLabel, isMultiYear, fiscalYears);
        this.renderDetailTable();

        // Negatives table
        UIRenderer.renderNegativesTable(aggregationResults.negatives);

        // Assumptions
        const methodology = BridgeCalculator.getMethodologyDescription(mode, gmPriceDefinition);
        const assumptionsConfig = {
            mode,
            gmPriceDefinition,
            fyEndMonth: this.state.fyEndMonth,
            pyRange,
            cyRange,
            dimensions: selectedDimensions,
            dateColumn: this.state.columnMappings.date,
            salesColumn: this.state.columnMappings.sales,
            quantityColumn: this.state.columnMappings.quantity,
            costColumn: this.state.columnMappings.cost
        };

        // Add fiscal years if in multi-year mode
        if (isMultiYear) {
            assumptionsConfig.fiscalYears = fiscalYears;
        }

        UIRenderer.renderAssumptions(assumptionsConfig, aggregationResults.stats, methodology);

        this.switchTab('summary');
    },

    renderDetailTable() {
        const { bridgeResults, aggregationResults, selectedDimensions, mode, sortBy, searchTerm, currentPage } = this.state;

        let results = bridgeResults.detail;
        results = BridgeCalculator.filterResults(results, searchTerm);
        results = BridgeCalculator.sortResults(results, sortBy);

        // Check if multi-year mode
        const isMultiYear = aggregationResults.isMultiYear;
        const fiscalYears = isMultiYear ?
            this.state.detectedFiscalYears.filter(fy => this.state.selectedFiscalYears.includes(fy.fiscalYear)) :
            [];

        UIRenderer.renderDetailTableBody(results, selectedDimensions, mode, currentPage, 50, isMultiYear, fiscalYears);
    },

    switchTab(tabId) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tabId));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.toggle('active', c.id === 'tab-' + tabId));
    },

    exportExcel() {
        const { aggregationResults } = this.state;
        const isMultiYear = aggregationResults.isMultiYear;

        const config = {
            mode: this.state.mode,
            gmPriceDefinition: this.state.gmPriceDefinition,
            fyEndMonth: this.state.fyEndMonth,
            pyRange: this.state.pyRange,
            cyRange: this.state.cyRange,
            pyLabel: this.state.pyLabel,
            cyLabel: this.state.cyLabel,
            dimensions: this.state.selectedDimensions,
            dateColumn: this.state.columnMappings.date,
            salesColumn: this.state.columnMappings.sales,
            quantityColumn: this.state.columnMappings.quantity,
            costColumn: this.state.columnMappings.cost
        };

        // Add fiscal years if in multi-year mode
        if (isMultiYear && this.state.selectedFiscalYears) {
            config.fiscalYears = this.state.detectedFiscalYears.filter(fy =>
                this.state.selectedFiscalYears.includes(fy.fiscalYear)
            );
        }

        ExcelExport.exportToExcel(this.state.bridgeResults, this.state.aggregationResults, config);
    }
});

    </script>
</body>
</html>
